[
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nA string s can be partitioned into groups of size k using the following procedure:\n\nThe first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each element can be a part of exactly one group.\nFor the last group, if the string does not have k characters remaining, a character fill is used to complete the group.\n\nNote that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s.\nGiven the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.\n \nExample 1:\n\nInput: s = \"abcdefghi\", k = 3, fill = \"x\"\nOutput: [\"abc\",\"def\",\"ghi\"]\nExplanation:\nThe first 3 characters \"abc\" form the first group.\nThe next 3 characters \"def\" form the second group.\nThe last 3 characters \"ghi\" form the third group.\nSince all groups can be completely filled by characters from the string, we do not need to use fill.\nThus, the groups formed are \"abc\", \"def\", and \"ghi\".\n\nExample 2:\n\nInput: s = \"abcdefghij\", k = 3, fill = \"x\"\nOutput: [\"abc\",\"def\",\"ghi\",\"jxx\"]\nExplanation:\nSimilar to the previous example, we are forming the first three groups \"abc\", \"def\", and \"ghi\".\nFor the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice.\nThus, the 4 groups formed are \"abc\", \"def\", \"ghi\", and \"jxx\".\n\n \nConstraints:\n\n1 <= s.length <= 100\ns consists of lowercase English letters only.\n1 <= k <= 100\nfill is a lowercase English letter.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def divideString(self, s: str, k: int, fill: str) -> List[str]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def divideString(self, s: str, k: int, fill: str) -> List[str]:\n        result = []\n        for i in range(0, len(s), k):\n            group = s[i:i+k]\n            if len(group) < k:\n                group += fill * (k - len(group))\n            result.append(group)\n        return result\n```\n\nThis solution iterates over the string `s` in steps of `k`, creating groups of size `k`. If the last group is smaller than `k`, it appends the `fill` character enough times to make it of size `k`. The groups are collected in the `result` list, which is returned at the end.",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "String",
        "Simulation"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given a 0-indexed integer array nums, and an integer k.\nIn one operation, you can remove one occurrence of the smallest element of nums.\nReturn the minimum number of operations needed so that all elements of the array are greater than or equal to k.\n \nExample 1:\n\nInput: nums = [2,11,10,1,3], k = 10\nOutput: 3\nExplanation: After one operation, nums becomes equal to [2, 11, 10, 3].\nAfter two operations, nums becomes equal to [11, 10, 3].\nAfter three operations, nums becomes equal to [11, 10].\nAt this stage, all the elements of nums are greater than or equal to 10 so we can stop.\nIt can be shown that 3 is the minimum number of operations needed so that all elements of the array are greater than or equal to 10.\n\nExample 2:\n\nInput: nums = [1,1,2,4,9], k = 1\nOutput: 0\nExplanation: All elements of the array are greater than or equal to 1 so we do not need to apply any operations on nums.\nExample 3:\n\nInput: nums = [1,1,2,4,9], k = 9\nOutput: 4\nExplanation: only a single element of nums is greater than or equal to 9 so we need to apply the operations 4 times on nums.\n\n \nConstraints:\n\n1 <= nums.length <= 50\n1 <= nums[i] <= 109\n1 <= k <= 109\nThe input is generated such that there is at least one index i such that nums[i] >= k.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        # Count the number of elements in nums that are less than k\n        operations = sum(1 for num in nums if num < k)\n        return operations\n```\n\nThis solution iterates through the list `nums` and counts how many elements are less than `k`. The count of these elements is the minimum number of operations needed to ensure all elements in the array are greater than or equal to `k`.",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given an array nums consisting of non-negative integers. You are also given a queries array, where queries[i] = [xi, mi].\nThe answer to the ith query is the maximum bitwise XOR value of xi and any element of nums that does not exceed mi. In other words, the answer is max(nums[j] XOR xi) for all j such that nums[j] <= mi. If all elements in nums are larger than mi, then the answer is -1.\nReturn an integer array answer where answer.length == queries.length and answer[i] is the answer to the ith query.\n \nExample 1:\n\nInput: nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]\nOutput: [3,3,7]\nExplanation:\n1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.\n2) 1 XOR 2 = 3.\n3) 5 XOR 2 = 7.\n\nExample 2:\n\nInput: nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]\nOutput: [15,-1,5]\n\n \nConstraints:\n\n1 <= nums.length, queries.length <= 105\nqueries[i].length == 2\n0 <= nums[j], xi, mi <= 109\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "To solve this problem efficiently, we can use a Trie (prefix tree) to store the binary representations of the numbers up to a certain limit (`mi` for each query). The Trie will help us find the maximum XOR value for each query efficiently.\n\nHere's the step-by-step approach:\n\n1. **Sort the `nums` array**: This allows us to only consider numbers up to `mi` for each query by using a two-pointer technique.\n2. **Sort the `queries` array by the `mi` value**: This allows us to incrementally add numbers to the Trie and handle each query in order of increasing `mi`.\n3. **Build a Trie for binary numbers**: The Trie will help us find the maximum XOR efficiently. Each node in the Trie will have two children, representing the binary digits 0 and 1.\n4. **Process each query**: For each query, add all numbers in `nums` that are less than or equal to `mi` to the Trie. Then, find the maximum XOR for `xi` using the Trie.\n5. **Return the results**: Store the results in the order of the original queries.\n\nHere is the implementation:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        # Step 1: Sort nums\n        nums.sort()\n        \n        # Step 2: Sort queries by the second element (mi) and keep track of original indices\n        sorted_queries = sorted(enumerate(queries), key=lambda x: x[1][1])\n        \n        # Step 3: Initialize the Trie\n        trie = {}\n        \n        # Helper function to add a number to the Trie\n        def add_to_trie(num):\n            node = trie\n            for i in range(31, -1, -1):  # Assuming numbers are up to 10^9, which fits in 30 bits\n                bit = (num >> i) & 1\n                if bit not in node:\n                    node[bit] = {}\n                node = node[bit]\n        \n        # Helper function to find the maximum XOR of xi with any number in the Trie\n        def max_xor(xi):\n            node = trie\n            if not node:\n                return -1\n            max_xor_value = 0\n            for i in range(31, -1, -1):\n                bit = (xi >> i) & 1\n                opposite_bit = 1 - bit\n                if opposite_bit in node:\n                    max_xor_value |= (1 << i)\n                    node = node[opposite_bit]\n                else:\n                    node = node[bit]\n            return max_xor_value\n        \n        # Step 4: Process each query\n        results = [-1] * len(queries)\n        nums_index = 0\n        for original_index, (xi, mi) in sorted_queries:\n            # Add all numbers <= mi to the Trie\n            while nums_index < len(nums) and nums[nums_index] <= mi:\n                add_to_trie(nums[nums_index])\n                nums_index += 1\n            # Find the maximum XOR for xi\n            results[original_index] = max_xor(xi)\n        \n        # Step 5: Return the results\n        return results\n```\n\nThis solution efficiently handles the constraints by leveraging a Trie to perform XOR operations in logarithmic time relative to the number of bits, which is suitable given the problem's constraints.",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Bit Manipulation",
        "Trie",
        "Array"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with  m rows and n columns using all the elements from original.\nThe elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.\nReturn an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.\n \nExample 1:\n\n\nInput: original = [1,2,3,4], m = 2, n = 2\nOutput: [[1,2],[3,4]]\nExplanation: The constructed 2D array should contain 2 rows and 2 columns.\nThe first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.\nThe second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.\n\nExample 2:\n\nInput: original = [1,2,3], m = 1, n = 3\nOutput: [[1,2,3]]\nExplanation: The constructed 2D array should contain 1 row and 3 columns.\nPut all three elements in original into the first row of the constructed 2D array.\n\nExample 3:\n\nInput: original = [1,2], m = 1, n = 1\nOutput: []\nExplanation: There are 2 elements in original.\nIt is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.\n\n \nConstraints:\n\n1 <= original.length <= 5 * 104\n1 <= original[i] <= 105\n1 <= m, n <= 4 * 104\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:\n        # Check if the total number of elements matches m * n\n        if len(original) != m * n:\n            return []\n        \n        # Construct the 2D array\n        result = []\n        for i in range(m):\n            row = original[i * n:(i + 1) * n]\n            result.append(row)\n        \n        return result\n```\n\nThis solution first checks if the length of the `original` list matches the product of `m` and `n`. If not, it returns an empty list as it's impossible to construct the 2D array. If the lengths match, it constructs the 2D array by slicing the `original` list into sublists of length `n` and appending each sublist to the result.",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Matrix",
        "Simulation"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nIn an infinite chess board with coordinates from -infinity to +infinity, you have a knight at square [0, 0].\nA knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.\n\nReturn the minimum number of steps needed to move the knight to the square [x, y]. It is guaranteed the answer exists.\n \nExample 1:\n\nInput: x = 2, y = 1\nOutput: 1\nExplanation: [0, 0] → [2, 1]\n\nExample 2:\n\nInput: x = 5, y = 5\nOutput: 4\nExplanation: [0, 0] → [2, 1] → [4, 2] → [3, 4] → [5, 5]\n\n \nConstraints:\n\n-300 <= x, y <= 300\n0 <= |x| + |y| <= 300\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def minKnightMoves(self, x: int, y: int) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nclass Solution:\n    def minKnightMoves(self, x: int, y: int) -> int:\n        # Since the board is symmetric, we can reduce the problem to the first quadrant\n        x, y = abs(x), abs(y)\n        \n        # Possible moves of a knight\n        moves = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n        \n        # BFS initialization\n        queue = [(0, 0, 0)]  # (current_x, current_y, steps)\n        visited = set((0, 0))\n        \n        while queue:\n            cx, cy, steps = queue.pop(0)\n            \n            # If we reach the target position\n            if (cx, cy) == (x, y):\n                return steps\n            \n            # Explore all possible moves\n            for dx, dy in moves:\n                nx, ny = cx + dx, cy + dy\n                # We only need to consider positions that haven't been visited and are not too close to the origin\n                if (nx, ny) not in visited and -2 < nx < x + 3 and -2 < ny < y + 3:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, steps + 1))\n```\n\nThis solution uses Breadth-First Search (BFS) to find the shortest path from the origin (0, 0) to the target (x, y) on an infinite chessboard. The BFS approach is suitable for this problem because it explores all possible moves level by level, ensuring that the first time it reaches the target, it does so with the minimum number of moves. The constraints are handled by limiting the search to a reasonable area around the target, given the nature of knight moves.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Breadth-First Search"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven the head of a linked list, return the list after sorting it in ascending order.\n \nExample 1:\n\n\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n\nExample 2:\n\n\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n\nExample 3:\n\nInput: head = []\nOutput: []\n\n \nConstraints:\n\nThe number of nodes in the list is in the range [0, 5 * 104].\n-105 <= Node.val <= 105\n\n \nFollow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)?\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "To solve the problem of sorting a linked list in ascending order with a time complexity of O(n log n) and a space complexity of O(1), we can use the merge sort algorithm. Merge sort is well-suited for linked lists because it does not require random access to elements, which is a limitation of linked lists compared to arrays.\n\nHere's the complete implementation:\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        # Find the middle of the list\n        middle = self.getMiddle(head)\n        next_to_middle = middle.next\n        middle.next = None\n        \n        # Recursively sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(next_to_middle)\n        \n        # Merge the sorted halves\n        sorted_list = self.sortedMerge(left, right)\n        \n        return sorted_list\n    \n    def getMiddle(self, head):\n        if not head:\n            return head\n        \n        slow = head\n        fast = head.next\n        \n        while fast:\n            fast = fast.next\n            if fast:\n                slow = slow.next\n                fast = fast.next\n        \n        return slow\n    \n    def sortedMerge(self, a, b):\n        result = None\n        \n        if not a:\n            return b\n        if not b:\n            return a\n        \n        if a.val <= b.val:\n            result = a\n            result.next = self.sortedMerge(a.next, b)\n        else:\n            result = b\n            result.next = self.sortedMerge(a, b.next)\n        \n        return result\n```\n\n### Explanation:\n1. **Base Case**: If the list is empty or has only one element (`head` is `None` or `head.next` is `None`), it is already sorted, so we return `head`.\n\n2. **Finding the Middle**: We use the `getMiddle` function to find the middle of the linked list. This function uses the slow and fast pointer technique to find the middle node. The slow pointer moves one step at a time, while the fast pointer moves two steps. When the fast pointer reaches the end, the slow pointer will be at the middle.\n\n3. **Recursive Sorting**: We recursively sort the two halves of the list. The first half starts from the head and ends at the middle, and the second half starts from the node next to the middle.\n\n4. **Merging**: We merge the two sorted halves using the `sortedMerge` function. This function takes two sorted linked lists and merges them into a single sorted linked list.\n\nThis implementation ensures that the linked list is sorted in O(n log n) time and uses O(1) additional space, meeting the constraints of the problem.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Linked List",
        "Two Pointers",
        "Divide and Conquer",
        "Sorting",
        "Merge Sort"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven an integer num, return a string of its base 7 representation.\n \nExample 1:\nInput: num = 100\nOutput: \"202\"\nExample 2:\nInput: num = -7\nOutput: \"-10\"\n\n \nConstraints:\n\n-107 <= num <= 107\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        if num == 0:\n            return \"0\"\n        \n        is_negative = num < 0\n        num = abs(num)\n        base7 = \"\"\n        \n        while num > 0:\n            base7 = str(num % 7) + base7\n            num //= 7\n        \n        if is_negative:\n            base7 = \"-\" + base7\n        \n        return base7\n```",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Math"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven a triangle array, return the minimum path sum from top to bottom.\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n \nExample 1:\n\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n\nExample 2:\n\nInput: triangle = [[-10]]\nOutput: -10\n\n \nConstraints:\n\n1 <= triangle.length <= 200\ntriangle[0].length == 1\ntriangle[i].length == triangle[i - 1].length + 1\n-104 <= triangle[i][j] <= 104\n\n \nFollow up: Could you do this using only O(n) extra space, where n is the total number of rows in the triangle?\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        n = len(triangle)\n        # Initialize a DP array with an extra column for easier calculations\n        dp = [0] * (n + 1)\n        \n        # Start from the bottom of the triangle and move upwards\n        for row in range(n - 1, -1, -1):\n            for col in range(row + 1):\n                # Update the DP array with the minimum path sum for each element\n                dp[col] = min(dp[col], dp[col + 1]) + triangle[row][col]\n        \n        # The top element now contains the minimum path sum\n        return dp[0]\n```\n\nThis solution uses dynamic programming with O(n) extra space, where `n` is the number of rows in the triangle. The `dp` array is updated in place, starting from the bottom row and moving upwards, to store the minimum path sums.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nA delivery company wants to build a new service center in a new city. The company knows the positions of all the customers in this city on a 2D-Map and wants to build the new center in a position such that the sum of the euclidean distances to all customers is minimum.\nGiven an array positions where positions[i] = [xi, yi] is the position of the ith customer on the map, return the minimum sum of the euclidean distances to all customers.\nIn other words, you need to choose the position of the service center [xcentre, ycentre] such that the following formula is minimized:\n\nAnswers within 10-5 of the actual value will be accepted.\n \nExample 1:\n\n\nInput: positions = [[0,1],[1,0],[1,2],[2,1]]\nOutput: 4.00000\nExplanation: As shown, you can see that choosing [xcentre, ycentre] = [1, 1] will make the distance to each customer = 1, the sum of all distances is 4 which is the minimum possible we can achieve.\n\nExample 2:\n\n\nInput: positions = [[1,1],[3,3]]\nOutput: 2.82843\nExplanation: The minimum possible sum of distances = sqrt(2) + sqrt(2) = 2.82843\n\n \nConstraints:\n\n1 <= positions.length <= 50\npositions[i].length == 2\n0 <= xi, yi <= 100\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def getMinDistSum(self, positions: List[List[int]]) -> float:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom math import sqrt\nfrom typing import List\n\nclass Solution:\n    def getMinDistSum(self, positions: List[List[int]]) -> float:\n        n = len(positions)\n        x = y = 0\n        for x1, y1 in positions:\n            x += x1\n            y += y1\n        x, y = x / n, y / n\n        decay = 0.999\n        eps = 1e-6\n        alpha = 0.5\n        while True:\n            grad_x = grad_y = 0\n            dist = 0\n            for x1, y1 in positions:\n                a = x - x1\n                b = y - y1\n                c = sqrt(a * a + b * b)\n                grad_x += a / (c + 1e-8)\n                grad_y += b / (c + 1e-8)\n                dist += c\n            dx = grad_x * alpha\n            dy = grad_y * alpha\n            x -= dx\n            y -= dy\n            alpha *= decay\n            if abs(dx) <= eps and abs(dy) <= eps:\n                return dist\n```\n\nThis solution uses a gradient descent approach to find the optimal position for the service center that minimizes the sum of Euclidean distances to all customers. The algorithm iteratively updates the position based on the gradient of the distance function until the changes in position are smaller than a specified tolerance (`eps`).",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Geometry",
        "Array",
        "Math",
        "Randomized"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nA decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.\nGiven a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.\n \nExample 1:\n\nInput: n = \"32\"\nOutput: 3\nExplanation: 10 + 11 + 11 = 32\n\nExample 2:\n\nInput: n = \"82734\"\nOutput: 8\n\nExample 3:\n\nInput: n = \"27346209830709182346\"\nOutput: 9\n\n \nConstraints:\n\n1 <= n.length <= 105\nn consists of only digits.\nn does not contain any leading zeros and represents a positive integer.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def minPartitions(self, n: str) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nclass Solution:\n    def minPartitions(self, n: str) -> int:\n        # The minimum number of deci-binary numbers needed is equal to the maximum digit in the string n.\n        # This is because each deci-binary number can contribute at most 1 to each digit place.\n        return max(int(digit) for digit in n)\n```\n\nThis solution works because the key insight is that the largest digit in the number `n` determines the minimum number of deci-binary numbers required. Each deci-binary number can contribute at most 1 to each digit place, so you need at least as many deci-binary numbers as the largest digit in `n` to sum up to `n`.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Greedy",
        "String"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven a positive integer num, split it into two non-negative integers num1 and num2 such that:\n\nThe concatenation of num1 and num2 is a permutation of num.\n\n\t\nIn other words, the sum of the number of occurrences of each digit in num1 and num2 is equal to the number of occurrences of that digit in num.\n\n\nnum1 and num2 can contain leading zeros.\n\nReturn the minimum possible sum of num1 and num2.\nNotes:\n\nIt is guaranteed that num does not contain any leading zeros.\nThe order of occurrence of the digits in num1 and num2 may differ from the order of occurrence of num.\n\n \nExample 1:\n\nInput: num = 4325\nOutput: 59\nExplanation: We can split 4325 so that num1 is 24 and num2 is 35, giving a sum of 59. We can prove that 59 is indeed the minimal possible sum.\n\nExample 2:\n\nInput: num = 687\nOutput: 75\nExplanation: We can split 687 so that num1 is 68 and num2 is 7, which would give an optimal sum of 75.\n\n \nConstraints:\n\n10 <= num <= 109\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def splitNum(self, num: int) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nclass Solution:\n    def splitNum(self, num: int) -> int:\n        # Convert the number to a string and sort its digits\n        digits = sorted(str(num))\n        \n        # Create two numbers by alternating digits from the sorted list\n        num1 = digits[::2]\n        num2 = digits[1::2]\n        \n        # Convert the lists of digits back to integers\n        num1 = int(''.join(num1))\n        num2 = int(''.join(num2))\n        \n        # Return the sum of the two numbers\n        return num1 + num2\n```\n\nThis solution works by first sorting the digits of the input number. Then, it alternates the digits to form two new numbers, `num1` and `num2`, which are then converted back to integers and summed. This approach ensures that the sum of the two numbers is minimized.",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Greedy",
        "Math",
        "Sorting"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given a string num consisting of digits only.\nReturn the largest palindromic integer (in the form of a string) that can be formed using digits taken from num. It should not contain leading zeroes.\nNotes:\n\nYou do not need to use all the digits of num, but you must use at least one digit.\nThe digits can be reordered.\n\n \nExample 1:\n\nInput: num = \"444947137\"\nOutput: \"7449447\"\nExplanation: \nUse the digits \"4449477\" from \"444947137\" to form the palindromic integer \"7449447\".\nIt can be shown that \"7449447\" is the largest palindromic integer that can be formed.\n\nExample 2:\n\nInput: num = \"00009\"\nOutput: \"9\"\nExplanation: \nIt can be shown that \"9\" is the largest palindromic integer that can be formed.\nNote that the integer returned should not contain leading zeroes.\n\n \nConstraints:\n\n1 <= num.length <= 105\nnum consists of digits.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def largestPalindromic(self, num: str) -> str:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nclass Solution:\n    def largestPalindromic(self, num: str) -> str:\n        from collections import Counter\n        \n        # Count the frequency of each digit\n        count = Counter(num)\n        \n        # Initialize the left part of the palindrome\n        left_part = []\n        \n        # Determine the middle digit (the largest odd count digit)\n        middle_digit = ''\n        \n        for digit in '9876543210':\n            if count[digit] > 1:\n                # Add half of the pairs to the left part\n                left_part.append(digit * (count[digit] // 2))\n            if not middle_digit and count[digit] % 2 == 1:\n                # Set the middle digit to the largest possible odd count digit\n                middle_digit = digit\n        \n        # Join the left part to form the left half of the palindrome\n        left_half = ''.join(left_part)\n        \n        # Check for leading zeros\n        if left_half and left_half[0] == '0':\n            # If the left part is all zeros, return the middle digit or '0'\n            return middle_digit if middle_digit else '0'\n        \n        # Form the full palindrome\n        return left_half + middle_digit + left_half[::-1]\n```\n\nThis solution constructs the largest palindromic number by first counting the occurrences of each digit. It then builds the left half of the palindrome using the largest available digits, ensuring that each digit is used in pairs. The largest digit with an odd count is used as the middle digit of the palindrome. Special care is taken to handle cases where the result might start with zeros, ensuring the output is a valid number without leading zeros.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Greedy",
        "Hash Table",
        "String",
        "Counting"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given two 0-indexed strings source and target, both of length n and consisting of lowercase English characters. You are also given two 0-indexed string arrays original and changed, and an integer array cost, where cost[i] represents the cost of converting the string original[i] to the string changed[i].\nYou start with the string source. In one operation, you can pick a substring x from the string, and change it to y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y. You are allowed to do any number of operations, but any pair of operations must satisfy either of these two conditions:\n\nThe substrings picked in the operations are source[a..b] and source[c..d] with either b < c or d < a. In other words, the indices picked in both operations are disjoint.\nThe substrings picked in the operations are source[a..b] and source[c..d] with a == c and b == d. In other words, the indices picked in both operations are identical.\n\nReturn the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.\nNote that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].\n \nExample 1:\n\nInput: source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]\nOutput: 28\nExplanation: To convert \"abcd\" to \"acbe\", do the following operations:\n- Change substring source[1..1] from \"b\" to \"c\" at a cost of 5.\n- Change substring source[2..2] from \"c\" to \"e\" at a cost of 1.\n- Change substring source[2..2] from \"e\" to \"b\" at a cost of 2.\n- Change substring source[3..3] from \"d\" to \"e\" at a cost of 20.\nThe total cost incurred is 5 + 1 + 2 + 20 = 28. \nIt can be shown that this is the minimum possible cost.\n\nExample 2:\n\nInput: source = \"abcdefgh\", target = \"acdeeghh\", original = [\"bcd\",\"fgh\",\"thh\"], changed = [\"cde\",\"thh\",\"ghh\"], cost = [1,3,5]\nOutput: 9\nExplanation: To convert \"abcdefgh\" to \"acdeeghh\", do the following operations:\n- Change substring source[1..3] from \"bcd\" to \"cde\" at a cost of 1.\n- Change substring source[5..7] from \"fgh\" to \"thh\" at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.\n- Change substring source[5..7] from \"thh\" to \"ghh\" at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.\nThe total cost incurred is 1 + 3 + 5 = 9.\nIt can be shown that this is the minimum possible cost.\n\nExample 3:\n\nInput: source = \"abcdefgh\", target = \"addddddd\", original = [\"bcd\",\"defgh\"], changed = [\"ddd\",\"ddddd\"], cost = [100,1578]\nOutput: -1\nExplanation: It is impossible to convert \"abcdefgh\" to \"addddddd\".\nIf you select substring source[1..3] as the first operation to change \"abcdefgh\" to \"adddefgh\", you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.\nIf you select substring source[3..7] as the first operation to change \"abcdefgh\" to \"abcddddd\", you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation.\n\n \nConstraints:\n\n1 <= source.length == target.length <= 1000\nsource, target consist only of lowercase English characters.\n1 <= cost.length == original.length == changed.length <= 100\n1 <= original[i].length == changed[i].length <= source.length\noriginal[i], changed[i] consist only of lowercase English characters.\noriginal[i] != changed[i]\n1 <= cost[i] <= 106\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "To solve this problem, we need to find the minimum cost to convert the string `source` to `target` using the allowed operations. The key idea is to use dynamic programming combined with the Floyd-Warshall algorithm to handle the minimum cost of converting substrings.\n\nHere is the step-by-step approach:\n\n1. **Graph Representation**: Represent the problem as a graph where each node is a substring (from the `original` and `changed` lists). The edges represent the costs of converting one substring to another.\n\n2. **Floyd-Warshall Algorithm**: Use the Floyd-Warshall algorithm to compute the shortest path (minimum cost) between all pairs of nodes (substrings). This will help us find the minimum cost to convert any substring `original[i]` to any substring `changed[j]`.\n\n3. **Dynamic Programming**: Use dynamic programming to find the minimum cost to convert the entire `source` string to the `target` string. We will use a DP array `dp` where `dp[i]` represents the minimum cost to convert the first `i` characters of `source` to the first `i` characters of `target`.\n\n4. **Initialization and Transition**: Initialize `dp[0]` to 0 (cost to convert an empty string to an empty string is 0). For each position `i` in the `source` string, try to match it with all possible substrings from the `original` list and update the `dp` array accordingly.\n\n5. **Result**: The value `dp[n]` (where `n` is the length of the strings) will give us the minimum cost to convert the entire `source` string to the `target` string. If it is not possible, the value will remain `float('inf')`, and we will return -1.\n\nHere is the implementation in Python:\n\n```python\nfrom typing import List\nfrom collections import defaultdict\nimport sys\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        # Step 1: Create a mapping from substring to its index\n        id = {}\n        for x in original + changed:\n            if x not in id:\n                id[x] = len(id)\n        \n        n = len(id)\n        # Step 2: Initialize the distance matrix with infinity\n        dist = [[sys.maxsize] * n for _ in range(n)]\n        for i in range(n):\n            dist[i][i] = 0\n        \n        # Step 3: Populate the distance matrix with given costs\n        for x, y, c in zip(original, changed, cost):\n            i, j = id[x], id[y]\n            dist[i][j] = min(dist[i][j], c)\n        \n        # Step 4: Use Floyd-Warshall to find all pairs shortest paths\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    if dist[i][k] < sys.maxsize and dist[k][j] < sys.maxsize:\n                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n        \n        # Step 5: Dynamic Programming to find the minimum cost to convert source to target\n        m = len(source)\n        dp = [sys.maxsize] * (m + 1)\n        dp[0] = 0\n        \n        for i in range(1, m + 1):\n            for j in range(i):\n                sub_s = source[j:i]\n                sub_t = target[j:i]\n                if sub_s == sub_t:\n                    dp[i] = min(dp[i], dp[j])\n                elif sub_s in id and sub_t in id:\n                    dp[i] = min(dp[i], dp[j] + dist[id[sub_s]][id[sub_t]])\n        \n        return dp[m] if dp[m] < sys.maxsize else -1\n```\n\n### Explanation:\n- **Graph Representation**: We map each unique substring in `original` and `changed` to a unique index.\n- **Floyd-Warshall**: We compute the shortest paths between all pairs of substrings using the given conversion costs.\n- **Dynamic Programming**: We iterate over each possible prefix of `source` and `target` and update the minimum cost to convert them using the precomputed shortest paths.\n\nThis approach ensures that we efficiently compute the minimum cost while respecting the constraints of disjoint or identical operations.",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Graph",
        "Trie",
        "Array",
        "String",
        "Dynamic Programming",
        "Shortest Path"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given a 0-indexed 2D integer array of events where events[i] = [startTimei, endTimei, valuei]. The ith event starts at startTimei and ends at endTimei, and if you attend this event, you will receive a value of valuei. You can choose at most two non-overlapping events to attend such that the sum of their values is maximized.\nReturn this maximum sum.\nNote that the start time and end time is inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time t, the next event must start at or after t + 1.\n \nExample 1:\n\n\nInput: events = [[1,3,2],[4,5,2],[2,4,3]]\nOutput: 4\nExplanation: Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.\n\nExample 2:\n\n\nInput: events = [[1,3,2],[4,5,2],[1,5,5]]\nOutput: 5\nExplanation: Choose event 2 for a sum of 5.\n\nExample 3:\n\n\nInput: events = [[1,5,3],[1,5,1],[6,6,5]]\nOutput: 8\nExplanation: Choose events 0 and 2 for a sum of 3 + 5 = 8.\n \nConstraints:\n\n2 <= events.length <= 105\nevents[i].length == 3\n1 <= startTimei <= endTimei <= 109\n1 <= valuei <= 106\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\nfrom bisect import bisect_right\n\nclass Solution:\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\n        # Sort events by their start times\n        events.sort()\n        \n        # Extract start times for binary search\n        start_times = [event[0] for event in events]\n        \n        # Initialize a suffix max array to store the maximum value of events from the current index to the end\n        n = len(events)\n        suffix_max = [0] * (n + 1)\n        suffix_max[n - 1] = events[n - 1][2]\n        \n        # Fill the suffix max array\n        for i in range(n - 2, -1, -1):\n            suffix_max[i] = max(suffix_max[i + 1], events[i][2])\n        \n        max_value = 0\n        \n        # Iterate through each event to find the maximum sum of two non-overlapping events\n        for i in range(n):\n            _, end, value = events[i]\n            # Find the first event that starts after the current event ends\n            next_event_index = bisect_right(start_times, end)\n            # Calculate the maximum value by considering the current event and the best non-overlapping event after it\n            max_value = max(max_value, value + suffix_max[next_event_index])\n        \n        return max_value\n```\n\nThis solution works as follows:\n1. **Sorting**: First, the events are sorted by their start times. This allows us to efficiently find the next non-overlapping event using binary search.\n2. **Suffix Maximum Array**: We create a suffix maximum array where `suffix_max[i]` contains the maximum value of events from index `i` to the end. This helps in quickly finding the maximum value of the second event that can be taken without overlapping.\n3. **Binary Search**: For each event, we use binary search (`bisect_right`) to find the first event that starts after the current event ends.\n4. **Max Calculation**: For each event, we calculate the maximum possible value by considering the current event and the best non-overlapping event found using the suffix maximum array.\n5. **Result**: The maximum value found during the iteration is returned as the result.\n\nThis approach ensures that we efficiently find the maximum sum of values of two non-overlapping events with a time complexity of O(n log n) due to sorting and binary search operations.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search",
        "Dynamic Programming",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given a 0-indexed array usageLimits of length n.\nYour task is to create groups using numbers from 0 to n - 1, ensuring that each number, i, is used no more than usageLimits[i] times in total across all groups. You must also satisfy the following conditions:\n\nEach group must consist of distinct numbers, meaning that no duplicate numbers are allowed within a single group.\nEach group (except the first one) must have a length strictly greater than the previous group.\n\nReturn an integer denoting the maximum number of groups you can create while satisfying these conditions.\n \nExample 1:\n\nInput: usageLimits = [1,2,5]\nOutput: 3\nExplanation: In this example, we can use 0 at most once, 1 at most twice, and 2 at most five times.\nOne way of creating the maximum number of groups while satisfying the conditions is: \nGroup 1 contains the number [2].\nGroup 2 contains the numbers [1,2].\nGroup 3 contains the numbers [0,1,2]. \nIt can be shown that the maximum number of groups is 3. \nSo, the output is 3. \nExample 2:\n\nInput: usageLimits = [2,1,2]\nOutput: 2\nExplanation: In this example, we can use 0 at most twice, 1 at most once, and 2 at most twice.\nOne way of creating the maximum number of groups while satisfying the conditions is:\nGroup 1 contains the number [0].\nGroup 2 contains the numbers [1,2].\nIt can be shown that the maximum number of groups is 2.\nSo, the output is 2. \n\nExample 3:\n\nInput: usageLimits = [1,1]\nOutput: 1\nExplanation: In this example, we can use both 0 and 1 at most once.\nOne way of creating the maximum number of groups while satisfying the conditions is:\nGroup 1 contains the number [0].\nIt can be shown that the maximum number of groups is 1.\nSo, the output is 1. \n\n \nConstraints:\n\n1 <= usageLimits.length <= 105\n1 <= usageLimits[i] <= 109\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        usageLimits.sort()\n        total = 0\n        groups = 0\n        \n        for limit in usageLimits:\n            total += limit\n            if total >= (groups + 1) * (groups + 2) // 2:\n                groups += 1\n        \n        return groups\n```\n\n### Explanation:\n1. **Sorting**: We start by sorting the `usageLimits` array. This allows us to build groups starting from the smallest possible numbers first, which helps in maximizing the number of groups.\n\n2. **Accumulating Total**: We maintain a running total of the numbers we can use. This total is incremented by each element in the sorted `usageLimits` array.\n\n3. **Checking Group Conditions**: For each number added to the total, we check if we can form a new group. The condition `(groups + 1) * (groups + 2) // 2` represents the sum of the first `groups + 1` natural numbers, which is the minimum number of distinct elements required to form `groups + 1` groups where each subsequent group has one more element than the previous one.\n\n4. **Increment Groups**: If the running total is sufficient to form the next group, we increment the `groups` counter.\n\nThis approach ensures that we are always trying to form the maximum number of groups while respecting the constraints given by `usageLimits`. The time complexity is dominated by the sorting step, making it O(n log n), which is efficient given the problem constraints.",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Greedy",
        "Array",
        "Math",
        "Binary Search",
        "Sorting"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven a 2D grid of size m x n, you should find the matrix answer of size m x n.\nThe cell answer[r][c] is calculated by looking at the diagonal values of the cell grid[r][c]:\n\nLet leftAbove[r][c] be the number of distinct values on the diagonal to the left and above the cell grid[r][c] not including the cell grid[r][c] itself.\nLet rightBelow[r][c] be the number of distinct values on the diagonal to the right and below the cell grid[r][c], not including the cell grid[r][c] itself.\nThen answer[r][c] = |leftAbove[r][c] - rightBelow[r][c]|.\n\nA matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until the end of the matrix is reached.\n\nFor example, in the below diagram the diagonal is highlighted using the cell with indices (2, 3) colored gray:\n\n\t\nRed-colored cells are left and above the cell.\nBlue-colored cells are right and below the cell.\n\n\n\n\nReturn the matrix answer.\n \nExample 1:\n\nInput: grid = [[1,2,3],[3,1,5],[3,2,1]]\nOutput: Output: [[1,1,0],[1,0,1],[0,1,1]]\nExplanation:\nTo calculate the answer cells:\n\n\n\nanswer\nleft-above elements\nleftAbove\nright-below elements\nrightBelow\n|leftAbove - rightBelow|\n\n\n\n\n[0][0]\n[]\n0\n[grid[1][1], grid[2][2]]\n|{1, 1}| = 1\n1\n\n\n[0][1]\n[]\n0\n[grid[1][2]]\n|{5}| = 1\n1\n\n\n[0][2]\n[]\n0\n[]\n0\n0\n\n\n[1][0]\n[]\n0\n[grid[2][1]]\n|{2}| = 1\n1\n\n\n[1][1]\n[grid[0][0]]\n|{1}| = 1\n[grid[2][2]]\n|{1}| = 1\n0\n\n\n[1][2]\n[grid[0][1]]\n|{2}| = 1\n[]\n0\n1\n\n\n[2][0]\n[]\n0\n[]\n0\n0\n\n\n[2][1]\n[grid[1][0]]\n|{3}| = 1\n[]\n0\n1\n\n\n[2][2]\n[grid[0][0], grid[1][1]]\n|{1, 1}| = 1\n[]\n0\n1\n\n\n\n\nExample 2:\n\nInput: grid = [[1]]\nOutput: Output: [[0]]\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n, grid[i][j] <= 50\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        answer = [[0] * n for _ in range(m)]\n        \n        # Function to calculate the number of distinct values in a diagonal\n        def count_distinct(diagonal):\n            return len(set(diagonal))\n        \n        # Calculate the answer for each cell\n        for r in range(m):\n            for c in range(n):\n                # Collect leftAbove diagonal values\n                left_above = []\n                i, j = r - 1, c - 1\n                while i >= 0 and j >= 0:\n                    left_above.append(grid[i][j])\n                    i -= 1\n                    j -= 1\n                \n                # Collect rightBelow diagonal values\n                right_below = []\n                i, j = r + 1, c + 1\n                while i < m and j < n:\n                    right_below.append(grid[i][j])\n                    i += 1\n                    j += 1\n                \n                # Calculate the answer for the current cell\n                answer[r][c] = abs(count_distinct(left_above) - count_distinct(right_below))\n        \n        return answer\n```\n\nThis solution iterates through each cell in the grid, collects the distinct values from the left-above and right-below diagonals, and calculates the absolute difference between the counts of these distinct values. The result is stored in the corresponding cell of the answer matrix.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Matrix"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nA certain bug's home is on the x-axis at position x. Help them get there from position 0.\nThe bug jumps according to the following rules:\n\nIt can jump exactly a positions forward (to the right).\nIt can jump exactly b positions backward (to the left).\nIt cannot jump backward twice in a row.\nIt cannot jump to any forbidden positions.\n\nThe bug may jump forward beyond its home, but it cannot jump to positions numbered with negative integers.\nGiven an array of integers forbidden, where forbidden[i] means that the bug cannot jump to the position forbidden[i], and integers a, b, and x, return the minimum number of jumps needed for the bug to reach its home. If there is no possible sequence of jumps that lands the bug on position x, return -1.\n \nExample 1:\n\nInput: forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9\nOutput: 3\nExplanation: 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home.\n\nExample 2:\n\nInput: forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\nOutput: -1\n\nExample 3:\n\nInput: forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7\nOutput: 2\nExplanation: One jump forward (0 -> 16) then one jump backward (16 -> 7) will get the bug home.\n\n \nConstraints:\n\n1 <= forbidden.length <= 1000\n1 <= a, b, forbidden[i] <= 2000\n0 <= x <= 2000\nAll the elements in forbidden are distinct.\nPosition x is not forbidden.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\nfrom collections import deque\n\nclass Solution:\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n        # Convert forbidden list to a set for O(1) lookups\n        forbidden_set = set(forbidden)\n        # Define a set to keep track of visited states (position, last_jump_direction)\n        visited = set()\n        # We start at position 0, with no previous jump (None for direction)\n        queue = deque([(0, None, 0)])  # (position, last_jump_direction, number_of_jumps)\n        # Define the maximum position to explore\n        max_position = 4000  # This is an upper bound based on the problem constraints\n        \n        while queue:\n            position, last_jump, jumps = queue.popleft()\n            \n            # If we reach the target position, return the number of jumps\n            if position == x:\n                return jumps\n            \n            # Calculate the next forward jump position\n            next_forward = position + a\n            # Check if the forward jump is within bounds, not forbidden, and not visited\n            if next_forward <= max_position and next_forward not in forbidden_set and (next_forward, 'forward') not in visited:\n                visited.add((next_forward, 'forward'))\n                queue.append((next_forward, 'forward', jumps + 1))\n            \n            # Calculate the next backward jump position\n            next_backward = position - b\n            # Check if the backward jump is within bounds, not forbidden, and not visited\n            # Also, ensure we haven't just jumped backward in the previous move\n            if next_backward >= 0 and next_backward not in forbidden_set and (next_backward, 'backward') not in visited and last_jump != 'backward':\n                visited.add((next_backward, 'backward'))\n                queue.append((next_backward, 'backward', jumps + 1))\n        \n        # If we exhaust the queue without finding a path to x, return -1\n        return -1\n```\n\nThis solution uses a breadth-first search (BFS) approach to explore all possible positions the bug can jump to, while keeping track of the number of jumps and ensuring that the bug does not violate the given constraints. The BFS ensures that the first time we reach position `x`, we have done so with the minimum number of jumps.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Breadth-First Search",
        "Array",
        "Dynamic Programming"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given a positive integer n.\nContinuously replace n with the sum of its prime factors.\n\nNote that if a prime factor divides n multiple times, it should be included in the sum as many times as it divides n.\n\nReturn the smallest value n will take on.\n \nExample 1:\n\nInput: n = 15\nOutput: 5\nExplanation: Initially, n = 15.\n15 = 3 * 5, so replace n with 3 + 5 = 8.\n8 = 2 * 2 * 2, so replace n with 2 + 2 + 2 = 6.\n6 = 2 * 3, so replace n with 2 + 3 = 5.\n5 is the smallest value n will take on.\n\nExample 2:\n\nInput: n = 3\nOutput: 3\nExplanation: Initially, n = 3.\n3 is the smallest value n will take on.\n\n \nConstraints:\n\n2 <= n <= 105\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "To solve the problem of finding the smallest value `n` will take on by continuously replacing `n` with the sum of its prime factors, we need to follow these steps:\n\n1. **Prime Factorization**: We need a function to find the prime factors of a number `n` and return their sum.\n2. **Iterative Replacement**: Continuously replace `n` with the sum of its prime factors until `n` no longer changes.\n3. **Edge Case**: If `n` is already a prime number and its smallest value, return `n`.\n\nHere's the complete Python solution:\n\n```python\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def sum_of_prime_factors(n: int) -> int:\n            sum_factors = 0\n            # Check for number of 2s that divide n\n            while n % 2 == 0:\n                sum_factors += 2\n                n //= 2\n            # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n            for i in range(3, int(n**0.5) + 1, 2):\n                # While i divides n, add i and divide n\n                while n % i == 0:\n                    sum_factors += i\n                    n //= i\n            # This condition is to check if n is a prime number greater than 2\n            if n > 2:\n                sum_factors += n\n            return sum_factors\n        \n        # Continue replacing n with the sum of its prime factors until it stabilizes\n        while True:\n            next_n = sum_of_prime_factors(n)\n            if next_n == n:\n                break\n            n = next_n\n        \n        return n\n\n# Example usage:\n# sol = Solution()\n# print(sol.smallestValue(15))  # Output: 5\n# print(sol.smallestValue(3))   # Output: 3\n```\n\n### Explanation:\n- **Prime Factorization Function (`sum_of_prime_factors`)**:\n  - We first handle the smallest prime number, `2`, separately to make the loop simpler.\n  - Then, we iterate through odd numbers starting from `3` up to the square root of `n` to find other prime factors.\n  - If `n` is still greater than `2` after the loop, it means `n` itself is a prime number and should be added to the sum.\n  \n- **Main Logic**:\n  - We use a `while` loop to continuously replace `n` with the sum of its prime factors.\n  - The loop breaks when `n` equals the sum of its prime factors, indicating that `n` has reached its smallest value.\n\nThis solution efficiently finds the smallest value `n` will take on by leveraging prime factorization and iterative replacement.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Number Theory",
        "Simulation"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven an integer numRows, return the first numRows of Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n\n \nExample 1:\nInput: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\nExample 2:\nInput: numRows = 1\nOutput: [[1]]\n\n \nConstraints:\n\n1 <= numRows <= 30\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 0:\n            return []\n        \n        triangle = [[1]]\n        \n        for i in range(1, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(triangle[i-1][j-1] + triangle[i-1][j])\n            row.append(1)\n            triangle.append(row)\n        \n        return triangle\n```\n\nThis solution generates Pascal's triangle up to the specified number of rows. It starts with the first row `[1]` and then iteratively builds each subsequent row by summing the appropriate elements from the previous row. Each row is appended to the `triangle` list, which is returned at the end.",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given an m x n integer matrix grid containing distinct positive integers.\nYou have to replace each integer in the matrix with a positive integer satisfying the following conditions:\n\nThe relative order of every two elements that are in the same row or column should stay the same after the replacements.\nThe maximum number in the matrix after the replacements should be as small as possible.\n\nThe relative order stays the same if for all pairs of elements in the original matrix such that grid[r1][c1] > grid[r2][c2] where either r1 == r2 or c1 == c2, then it must be true that grid[r1][c1] > grid[r2][c2] after the replacements.\nFor example, if grid = [[2, 4, 5], [7, 3, 9]] then a good replacement could be either grid = [[1, 2, 3], [2, 1, 4]] or grid = [[1, 2, 3], [3, 1, 4]].\nReturn the resulting matrix. If there are multiple answers, return any of them.\n \nExample 1:\n\n\nInput: grid = [[3,1],[2,5]]\nOutput: [[2,1],[1,2]]\nExplanation: The above diagram shows a valid replacement.\nThe maximum number in the matrix is 2. It can be shown that no smaller value can be obtained.\n\nExample 2:\n\nInput: grid = [[10]]\nOutput: [[1]]\nExplanation: We replace the only number in the matrix with 1.\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\n1 <= grid[i][j] <= 109\ngrid consists of distinct integers.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def minScore(self, grid: List[List[int]]) -> List[List[int]]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "To solve this problem, we need to replace each integer in the matrix with a positive integer such that the relative order of elements in the same row or column is maintained, and the maximum number in the matrix is minimized.\n\nHere's a step-by-step approach to achieve this:\n\n1. **Flatten and Sort the Matrix**: First, we flatten the matrix and sort the elements along with their original positions. This helps us determine the order in which we should assign the new values.\n\n2. **Track Row and Column Maximums**: We need to keep track of the current maximum value assigned in each row and column to ensure that the relative order is maintained.\n\n3. **Assign New Values**: For each element in the sorted list, we assign the smallest possible value that is greater than the maximum value in its row and column.\n\n4. **Reconstruct the Matrix**: Finally, we reconstruct the matrix with the new values.\n\nHere's the implementation of the above approach:\n\n```python\nfrom typing import List\nimport bisect\n\nclass Solution:\n    def minScore(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        \n        # Flatten the grid and sort by value\n        flat_grid = [(grid[i][j], i, j) for i in range(m) for j in range(n)]\n        flat_grid.sort()\n        \n        # Initialize row and column max arrays\n        row_max = [0] * m\n        col_max = [0] * n\n        \n        # Resultant grid\n        result = [[0] * n for _ in range(m)]\n        \n        # Assign values\n        for value, i, j in flat_grid:\n            # The new value should be greater than the max in the current row and column\n            new_value = max(row_max[i], col_max[j]) + 1\n            result[i][j] = new_value\n            # Update the row and column max\n            row_max[i] = new_value\n            col_max[j] = new_value\n        \n        return result\n```\n\n### Explanation:\n- **Flattening and Sorting**: We create a list of tuples where each tuple contains the value, row index, and column index of each element in the grid. We then sort this list by the value.\n- **Tracking Maximums**: We maintain two lists, `row_max` and `col_max`, to keep track of the maximum value assigned in each row and column so far.\n- **Assigning Values**: For each element in the sorted list, we determine the smallest possible value that is greater than the maximum value in its row and column, and assign it to the result matrix.\n- **Updating Maximums**: After assigning a new value, we update the corresponding `row_max` and `col_max`.\n\nThis approach ensures that the relative order is maintained and the maximum value in the matrix is minimized. The time complexity is dominated by the sorting step, which is \\(O(m \\times n \\log(m \\times n))\\).",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Union Find",
        "Graph",
        "Topological Sort",
        "Array",
        "Matrix",
        "Sorting"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven a m * n matrix seats  that represent seats distributions in a classroom. If a seat is broken, it is denoted by '#' character otherwise it is denoted by a '.' character.\nStudents can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting directly in front or behind him. Return the maximum number of students that can take the exam together without any cheating being possible.\nStudents must be placed in seats in good condition.\n \nExample 1:\n\n\nInput: seats = [[\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n                [\".\",\"#\",\"#\",\"#\",\"#\",\".\"],\n                [\"#\",\".\",\"#\",\"#\",\".\",\"#\"]]\nOutput: 4\nExplanation: Teacher can place 4 students in available seats so they don't cheat on the exam. \n\nExample 2:\n\nInput: seats = [[\".\",\"#\"],\n                [\"#\",\"#\"],\n                [\"#\",\".\"],\n                [\"#\",\"#\"],\n                [\".\",\"#\"]]\nOutput: 3\nExplanation: Place all students in available seats. \n\n\nExample 3:\n\nInput: seats = [[\"#\",\".\",\".\",\".\",\"#\"],\n                [\".\",\"#\",\".\",\"#\",\".\"],\n                [\".\",\".\",\"#\",\".\",\".\"],\n                [\".\",\"#\",\".\",\"#\",\".\"],\n                [\"#\",\".\",\".\",\".\",\"#\"]]\nOutput: 10\nExplanation: Place students in available seats in column 1, 3 and 5.\n\n \nConstraints:\n\nseats contains only characters '.' and'#'.\nm == seats.length\nn == seats[i].length\n1 <= m <= 8\n1 <= n <= 8\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def maxStudents(self, seats: List[List[str]]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "To solve this problem, we can use dynamic programming with bit masking. The idea is to represent each row of seats as a bitmask and use dynamic programming to keep track of the maximum number of students that can be seated without cheating. Here's a step-by-step explanation of the approach:\n\n1. **Bitmask Representation**: Represent each row of seats as a bitmask where `1` indicates a broken seat and `0` indicates an available seat. This allows us to efficiently check if a student can be placed in a seat and to check the constraints for adjacency.\n\n2. **Dynamic Programming Table**: Use a dynamic programming table `dp` where `dp[r][mask]` represents the maximum number of students that can be seated up to row `r` with the last row's seating arrangement represented by `mask`.\n\n3. **Transition Between Rows**: For each row, try all possible valid seating arrangements (masks) and update the `dp` table by considering all valid previous row seating arrangements. A seating arrangement is valid if:\n   - No two students are adjacent in the same row.\n   - No student can see another student from the previous row (i.e., no student directly above, below, or diagonally above-left or above-right).\n\n4. **Result Calculation**: The result will be the maximum value in the last row of the `dp` table.\n\nHere's the implementation of the solution:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def maxStudents(self, seats: List[List[str]]) -> int:\n        m, n = len(seats), len(seats[0])\n        \n        # Convert each row to a bitmask\n        def to_mask(row):\n            mask = 0\n            for seat in row:\n                mask = (mask << 1) | (1 if seat == '#' else 0)\n            return mask\n        \n        # Generate all possible valid masks for a row\n        def generate_valid_masks():\n            valid_masks = []\n            for mask in range(1 << n):\n                if (mask & (mask >> 1)) == 0:  # No two students adjacent\n                    valid_masks.append(mask)\n            return valid_masks\n        \n        # Check if mask1 can be placed below mask2 without cheating\n        def is_valid(mask1, mask2):\n            return (mask1 & (mask2 >> 1)) == 0 and (mask1 & (mask2 << 1)) == 0\n        \n        # Convert rows to bitmasks\n        row_masks = [to_mask(row) for row in seats]\n        valid_masks = generate_valid_masks()\n        \n        # Initialize dp table\n        dp = [[-1] * (1 << n) for _ in range(m)]\n        \n        # Fill the first row of dp table\n        for mask in valid_masks:\n            if (mask & row_masks[0]) == 0:  # No broken seats in this arrangement\n                dp[0][mask] = bin(mask).count('1')\n        \n        # Fill the rest of the dp table\n        for r in range(1, m):\n            for mask1 in valid_masks:\n                if (mask1 & row_masks[r]) == 0:  # No broken seats in this arrangement\n                    for mask2 in valid_masks:\n                        if is_valid(mask1, mask2):\n                            dp[r][mask1] = max(dp[r][mask1], dp[r-1][mask2] + bin(mask1).count('1'))\n        \n        # The answer is the maximum value in the last row of dp table\n        return max(dp[-1])\n\n# Example usage:\n# sol = Solution()\n# print(sol.maxStudents([[\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n#                        [\".\",\"#\",\"#\",\"#\",\"#\",\".\"],\n#                        [\"#\",\".\",\"#\",\"#\",\".\",\"#\"]]))  # Output: 4\n```\n\nThis solution efficiently computes the maximum number of students that can be seated without cheating using dynamic programming and bit masking. The constraints of the problem (with `m` and `n` up to 8) make this approach feasible.",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Bit Manipulation",
        "Array",
        "Dynamic Programming",
        "Bitmask",
        "Matrix"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven an array of integers arr and an integer k. Find the least number of unique integers after removing exactly k elements.\\r\n\\r\n\\r\n\\r\n\\r\n \\r\nExample 1:\\r\n\\r\n\\r\nInput: arr = [5,5,4], k = 1\\r\nOutput: 1\\r\nExplanation: Remove the single 4, only 5 is left.\\r\n\\r\nExample 2:\\r\n\\r\n\\r\nInput: arr = [4,3,1,1,3,3,2], k = 3\\r\nOutput: 2\\r\nExplanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.\\r\n\\r\n \\r\nConstraints:\\r\n\\r\n\\r\n\t1 <= arr.length <= 10^5\\r\n\t1 <= arr[i] <= 10^9\\r\n\t0 <= k <= arr.length\\r\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom collections import Counter\nfrom typing import List\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        # Count the frequency of each number in the array\n        count = Counter(arr)\n        \n        # Sort the items by their frequency\n        sorted_count = sorted(count.items(), key=lambda x: x[1])\n        \n        # Initialize the number of unique integers\n        unique_count = len(sorted_count)\n        \n        # Iterate over the sorted items\n        for num, freq in sorted_count:\n            if k >= freq:\n                # If k is greater than or equal to the frequency of the current number\n                # We can remove all occurrences of this number\n                k -= freq\n                unique_count -= 1\n            else:\n                # If k is less than the frequency of the current number\n                # We cannot remove all occurrences, so we stop here\n                break\n        \n        return unique_count\n```\n\nThis solution works by first counting the frequency of each integer in the array. It then sorts these frequencies in ascending order. By iterating through the sorted frequencies, it removes the least frequent integers first until `k` elements have been removed. The result is the number of unique integers remaining in the array.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Greedy",
        "Array",
        "Hash Table",
        "Counting",
        "Sorting"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven an array of integers nums, half of the integers in nums are odd, and the other half are even.\nSort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even.\nReturn any answer array that satisfies this condition.\n \nExample 1:\n\nInput: nums = [4,2,5,7]\nOutput: [4,5,2,7]\nExplanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\n\nExample 2:\n\nInput: nums = [2,3]\nOutput: [2,3]\n\n \nConstraints:\n\n2 <= nums.length <= 2 * 104\nnums.length is even.\nHalf of the integers in nums are even.\n0 <= nums[i] <= 1000\n\n \nFollow Up: Could you solve it in-place?\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nclass Solution:\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\n        even_index = 0\n        odd_index = 1\n        n = len(nums)\n        \n        while even_index < n and odd_index < n:\n            if nums[even_index] % 2 == 0:\n                even_index += 2\n            elif nums[odd_index] % 2 == 1:\n                odd_index += 2\n            else:\n                # Swap elements at even_index and odd_index\n                nums[even_index], nums[odd_index] = nums[odd_index], nums[even_index]\n                even_index += 2\n                odd_index += 2\n        \n        return nums\n```\n\nThis solution sorts the array in-place by maintaining two pointers: one for the even indices and one for the odd indices. It iterates through the array, swapping elements when necessary to ensure that even numbers are at even indices and odd numbers are at odd indices. The process continues until all elements are correctly placed.",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Two Pointers",
        "Sorting"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\n \nExample 1:\n\nInput: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.\n\nExample 2:\n\nInput: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9.\n\n \nConstraints:\n\n1 <= n <= 104\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        # Create a list to store the minimum number of perfect squares for each number up to n\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0  # Base case: 0 can be represented by 0 perfect squares\n        \n        # Precompute all perfect squares less than or equal to n\n        squares = []\n        i = 1\n        while i * i <= n:\n            squares.append(i * i)\n            i += 1\n        \n        # Fill the dp array\n        for i in range(1, n + 1):\n            for square in squares:\n                if i < square:\n                    break\n                dp[i] = min(dp[i], dp[i - square] + 1)\n        \n        return dp[n]\n```\n\nThis solution uses dynamic programming to find the minimum number of perfect squares that sum to `n`. The `dp` array is used to store the minimum number of perfect squares for each number up to `n`. We iterate through each number and update the `dp` array by considering each perfect square less than or equal to that number. The final result is stored in `dp[n]`.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Breadth-First Search",
        "Math",
        "Dynamic Programming"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\n \nExample 1:\n\nInput: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.\nExample 2:\n\nInput: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned.\n\n \nConstraints:\n\n1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def longestIdealString(self, s: str, k: int) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nclass Solution:\n    def longestIdealString(self, s: str, k: int) -> int:\n        # Initialize an array to keep track of the longest subsequence ending with each character\n        dp = [0] * 26\n        \n        for char in s:\n            # Convert character to index (0 for 'a', 1 for 'b', ..., 25 for 'z')\n            index = ord(char) - ord('a')\n            \n            # Calculate the maximum length of the ideal subsequence ending with this character\n            max_length = 1\n            for offset in range(-k, k + 1):\n                if 0 <= index + offset < 26:\n                    max_length = max(max_length, dp[index + offset] + 1)\n            \n            # Update the dp array with the calculated maximum length\n            dp[index] = max_length\n        \n        # The result is the maximum value in the dp array\n        return max(dp)\n```\n\nThis solution uses dynamic programming to keep track of the longest ideal subsequence ending with each character. It iterates through each character in the string, calculates the possible previous characters that could form an ideal subsequence, and updates the dp array accordingly. Finally, the length of the longest ideal subsequence is the maximum value in the dp array.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Dynamic Programming"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given two strings a and b that consist of lowercase letters. In one operation, you can change any character in a or b to any lowercase letter.\nYour goal is to satisfy one of the following three conditions:\n\nEvery letter in a is strictly less than every letter in b in the alphabet.\nEvery letter in b is strictly less than every letter in a in the alphabet.\nBoth a and b consist of only one distinct letter.\n\nReturn the minimum number of operations needed to achieve your goal.\n \nExample 1:\n\nInput: a = \"aba\", b = \"caa\"\nOutput: 2\nExplanation: Consider the best way to make each condition true:\n1) Change b to \"ccc\" in 2 operations, then every letter in a is less than every letter in b.\n2) Change a to \"bbb\" and b to \"aaa\" in 3 operations, then every letter in b is less than every letter in a.\n3) Change a to \"aaa\" and b to \"aaa\" in 2 operations, then a and b consist of one distinct letter.\nThe best way was done in 2 operations (either condition 1 or condition 3).\n\nExample 2:\n\nInput: a = \"dabadd\", b = \"cda\"\nOutput: 3\nExplanation: The best way is to make condition 1 true by changing b to \"eee\".\n\n \nConstraints:\n\n1 <= a.length, b.length <= 105\na and b consist only of lowercase letters.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        # Count the frequency of each character in both strings\n        count_a = [0] * 26\n        count_b = [0] * 26\n        \n        for char in a:\n            count_a[ord(char) - ord('a')] += 1\n            \n        for char in b:\n            count_b[ord(char) - ord('a')] += 1\n            \n        total_operations = float('inf')\n        n = len(a)\n        m = len(b)\n        \n        # Condition 3: Both a and b consist of only one distinct letter\n        for i in range(26):\n            total_operations = min(total_operations, n + m - count_a[i] - count_b[i])\n        \n        # Condition 1 and 2: Every letter in a is strictly less than every letter in b or vice versa\n        prefix_a = 0\n        prefix_b = 0\n        \n        for i in range(25):  # We don't need to check for 'z' as there is no character after 'z'\n            prefix_a += count_a[i]\n            prefix_b += count_b[i]\n            \n            # Calculate operations needed for condition 1: all characters in a < all characters in b\n            operations_1 = prefix_a + (m - prefix_b)\n            \n            # Calculate operations needed for condition 2: all characters in b < all characters in a\n            operations_2 = prefix_b + (n - prefix_a)\n            \n            total_operations = min(total_operations, operations_1, operations_2)\n        \n        return total_operations\n```\n\nThis solution efficiently calculates the minimum number of operations needed to satisfy one of the three conditions by leveraging character frequency counts and prefix sums. It handles all given constraints and examples correctly.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Counting",
        "Prefix Sum"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given n item's value and label as two integer arrays values and labels. You are also given two integers numWanted and useLimit.\nYour task is to find a subset of items with the maximum sum of their values such that:\n\nThe number of items is at most numWanted.\nThe number of items with the same label is at most useLimit.\n\nReturn the maximum sum.\n \nExample 1:\n\nInput: values = [5,4,3,2,1], labels = [1,1,2,2,3], numWanted = 3, useLimit = 1\nOutput: 9\nExplanation:\nThe subset chosen is the first, third, and fifth items with the sum of values 5 + 3 + 1.\n\nExample 2:\n\nInput: values = [5,4,3,2,1], labels = [1,3,3,3,2], numWanted = 3, useLimit = 2\nOutput: 12\nExplanation:\nThe subset chosen is the first, second, and third items with the sum of values 5 + 4 + 3.\n\nExample 3:\n\nInput: values = [9,8,8,7,6], labels = [0,0,0,1,1], numWanted = 3, useLimit = 1\nOutput: 16\nExplanation:\nThe subset chosen is the first and fourth items with the sum of values 9 + 7.\n\n \nConstraints:\n\nn == values.length == labels.length\n1 <= n <= 2 * 104\n0 <= values[i], labels[i] <= 2 * 104\n1 <= numWanted, useLimit <= n\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:\n        # Combine values and labels into a single list of tuples and sort by value in descending order\n        items = sorted(zip(values, labels), reverse=True)\n        \n        # Dictionary to keep track of the number of items used from each label\n        label_count = defaultdict(int)\n        \n        max_sum = 0\n        items_count = 0\n        \n        # Iterate over the sorted items\n        for value, label in items:\n            # Check if we can still add items and if the current label has not reached its use limit\n            if items_count < numWanted and label_count[label] < useLimit:\n                max_sum += value\n                label_count[label] += 1\n                items_count += 1\n            \n            # If we have already selected the required number of items, break the loop\n            if items_count == numWanted:\n                break\n        \n        return max_sum\n```\n\nThis solution first combines the values and labels into a list of tuples and sorts this list in descending order based on the values. It then iterates over the sorted list, adding items to the subset if they do not exceed the `useLimit` for their label and if the total number of items in the subset is less than `numWanted`. The process continues until the subset contains the desired number of items or there are no more items that can be added without violating the constraints.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Greedy",
        "Array",
        "Hash Table",
        "Counting",
        "Sorting"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\n \nExample 1:\n\nInput: nums = [1,2,3,1]\nOutput: true\nExplanation:\nThe element 1 occurs at the indices 0 and 3.\n\nExample 2:\n\nInput: nums = [1,2,3,4]\nOutput: false\nExplanation:\nAll elements are distinct.\n\nExample 3:\n\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n\n \nConstraints:\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        # Use a set to track seen numbers\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False\n```\n\nThis solution uses a set to keep track of the numbers we have already seen as we iterate through the list. If we encounter a number that is already in the set, we return `True` because it means the number appears at least twice. If we finish iterating through the list without finding any duplicates, we return `False`. This approach is efficient with a time complexity of O(n) and a space complexity of O(n).",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Sorting"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nThere is a hidden integer array arr that consists of n non-negative integers.\nIt was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3].\nYou are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0].\nReturn the original array arr. It can be proved that the answer exists and is unique.\n \nExample 1:\n\nInput: encoded = [1,2,3], first = 1\nOutput: [1,0,2,1]\nExplanation: If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]\n\nExample 2:\n\nInput: encoded = [6,2,7,3], first = 4\nOutput: [4,2,0,7,4]\n\n \nConstraints:\n\n2 <= n <= 104\nencoded.length == n - 1\n0 <= encoded[i] <= 105\n0 <= first <= 105\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def decode(self, encoded: List[int], first: int) -> List[int]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def decode(self, encoded: List[int], first: int) -> List[int]:\n        # Initialize the result array with the first element\n        arr = [first]\n        \n        # Iterate through the encoded array\n        for num in encoded:\n            # Decode the next element and append it to the result array\n            next_element = arr[-1] ^ num\n            arr.append(next_element)\n        \n        return arr\n```\n\nThis solution initializes the result array `arr` with the given `first` element. It then iterates through the `encoded` array, decoding each element by XORing the last element of the result array with the current encoded value. The decoded value is appended to the result array. This process reconstructs the original array `arr` from the encoded array.",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Bit Manipulation",
        "Array"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nThere is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.\nYou are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all (0 <= i < n). Return the highest altitude of a point.\n \nExample 1:\n\nInput: gain = [-5,1,5,0,-7]\nOutput: 1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.\n\nExample 2:\n\nInput: gain = [-4,-3,-2,-1,4,3,2]\nOutput: 0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.\n\n \nConstraints:\n\nn == gain.length\n1 <= n <= 100\n-100 <= gain[i] <= 100\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def largestAltitude(self, gain: List[int]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def largestAltitude(self, gain: List[int]) -> int:\n        current_altitude = 0\n        highest_altitude = 0\n        \n        for g in gain:\n            current_altitude += g\n            highest_altitude = max(highest_altitude, current_altitude)\n        \n        return highest_altitude\n```\n\nThis solution initializes the `current_altitude` to 0 and `highest_altitude` to 0. It then iterates through the `gain` list, updating the `current_altitude` by adding each gain value. After updating the `current_altitude`, it checks if this is the highest altitude encountered so far and updates `highest_altitude` accordingly. Finally, it returns the `highest_altitude`.",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Prefix Sum"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given a string s consisting of only lowercase English letters. In one operation, you can:\n\nDelete the entire string s, or\nDelete the first i letters of s if the first i letters of s are equal to the following i letters in s, for any i in the range 1 <= i <= s.length / 2.\n\nFor example, if s = \"ababc\", then in one operation, you could delete the first two letters of s to get \"abc\", since the first two letters of s and the following two letters of s are both equal to \"ab\".\nReturn the maximum number of operations needed to delete all of s.\n \nExample 1:\n\nInput: s = \"abcabcdabc\"\nOutput: 2\nExplanation:\n- Delete the first 3 letters (\"abc\") since the next 3 letters are equal. Now, s = \"abcdabc\".\n- Delete all the letters.\nWe used 2 operations so return 2. It can be proven that 2 is the maximum number of operations needed.\nNote that in the second operation we cannot delete \"abc\" again because the next occurrence of \"abc\" does not happen in the next 3 letters.\n\nExample 2:\n\nInput: s = \"aaabaab\"\nOutput: 4\nExplanation:\n- Delete the first letter (\"a\") since the next letter is equal. Now, s = \"aabaab\".\n- Delete the first 3 letters (\"aab\") since the next 3 letters are equal. Now, s = \"aab\".\n- Delete the first letter (\"a\") since the next letter is equal. Now, s = \"ab\".\n- Delete all the letters.\nWe used 4 operations so return 4. It can be proven that 4 is the maximum number of operations needed.\n\nExample 3:\n\nInput: s = \"aaaaa\"\nOutput: 5\nExplanation: In each operation, we can delete the first letter of s.\n\n \nConstraints:\n\n1 <= s.length <= 4000\ns consists only of lowercase English letters.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def deleteString(self, s: str) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "To solve this problem, we can use dynamic programming with memoization. The idea is to recursively determine the maximum number of operations needed to delete the string starting from each position. We will use a cache to store the results of subproblems to avoid redundant calculations.\n\nHere's the implementation:\n\n```python\nclass Solution:\n    def deleteString(self, s: str) -> int:\n        from functools import lru_cache\n        \n        @lru_cache(None)\n        def dp(start):\n            if start == len(s):\n                return 0\n            \n            max_ops = 1  # At least one operation to delete the entire remaining string\n            \n            # Try to find the longest prefix that matches a suffix starting from start\n            for i in range(1, (len(s) - start) // 2 + 1):\n                if s[start:start + i] == s[start + i:start + 2 * i]:\n                    max_ops = max(max_ops, 1 + dp(start + i))\n            \n            return max_ops\n        \n        return dp(0)\n```\n\n### Explanation:\n\n1. **Memoization with `lru_cache`**: We use `lru_cache` to memoize the results of the `dp` function. This helps in avoiding recalculating the maximum operations for the same starting index multiple times.\n\n2. **Base Case**: If `start` is equal to the length of the string, it means there are no characters left to delete, so we return 0.\n\n3. **Recursive Case**: We initialize `max_ops` to 1, which accounts for the operation of deleting the entire remaining substring. Then, we iterate over possible lengths of prefixes (`i`) that can be deleted. If the prefix matches the next segment of the same length, we recursively calculate the maximum operations for the remaining substring starting from `start + i` and update `max_ops` accordingly.\n\n4. **Return the Result**: Finally, we call `dp(0)` to get the maximum number of operations needed to delete the entire string starting from the beginning.\n\nThis approach ensures that we efficiently explore all possible ways to delete the string while keeping track of the maximum number of operations. The use of memoization helps in managing the time complexity, making it feasible to solve the problem within the given constraints.",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "String",
        "Dynamic Programming",
        "String Matching",
        "Hash Function",
        "Rolling Hash"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi.\nYou can attend an event i at any day d where startTimei <= d <= endTimei. You can only attend one event at any time d.\nReturn the maximum number of events you can attend.\n \nExample 1:\n\n\nInput: events = [[1,2],[2,3],[3,4]]\nOutput: 3\nExplanation: You can attend all the three events.\nOne way to attend them all is as shown.\nAttend the first event on day 1.\nAttend the second event on day 2.\nAttend the third event on day 3.\n\nExample 2:\n\nInput: events= [[1,2],[2,3],[3,4],[1,2]]\nOutput: 4\n\n \nConstraints:\n\n1 <= events.length <= 105\nevents[i].length == 2\n1 <= startDayi <= endDayi <= 105\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def maxEvents(self, events: List[List[int]]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def maxEvents(self, events: List[List[int]]) -> int:\n        # Sort events by their start day\n        events.sort()\n        min_heap = []  # This will store the end days of events\n        day = 0  # Current day\n        event_index = 0  # Index to track the current event\n        max_events_attended = 0  # Count of events attended\n\n        # Iterate through the days\n        while event_index < len(events) or min_heap:\n            # If the heap is empty, fast forward to the next event's start day\n            if not min_heap:\n                day = events[event_index][0]\n            \n            # Push all events that start on the current day into the heap\n            while event_index < len(events) and events[event_index][0] == day:\n                heapq.heappush(min_heap, events[event_index][1])\n                event_index += 1\n            \n            # Attend the event that ends the earliest\n            heapq.heappop(min_heap)\n            max_events_attended += 1\n            day += 1\n            \n            # Remove all events from the heap that have already ended\n            while min_heap and min_heap[0] < day:\n                heapq.heappop(min_heap)\n\n        return max_events_attended\n```\n\nThis solution efficiently handles the problem constraints by using a priority queue (min-heap) to always attend the event that ends the earliest on any given day. The algorithm sorts the events by their start day and iterates through each day, adding events that start on that day to the heap and attending the event that ends the earliest. It also removes events from the heap that have already ended before the current day.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "Greedy",
        "Array",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given two strings s and t such that every character occurs at most once in s and t is a permutation of s.\nThe permutation difference between s and t is defined as the sum of the absolute difference between the index of the occurrence of each character in s and the index of the occurrence of the same character in t.\nReturn the permutation difference between s and t.\n \nExample 1:\n\nInput: s = \"abc\", t = \"bac\"\nOutput: 2\nExplanation:\nFor s = \"abc\" and t = \"bac\", the permutation difference of s and t is equal to the sum of:\n\nThe absolute difference between the index of the occurrence of \"a\" in s and the index of the occurrence of \"a\" in t.\nThe absolute difference between the index of the occurrence of \"b\" in s and the index of the occurrence of \"b\" in t.\nThe absolute difference between the index of the occurrence of \"c\" in s and the index of the occurrence of \"c\" in t.\n\nThat is, the permutation difference between s and t is equal to |0 - 1| + |1 - 0| + |2 - 2| = 2.\n\nExample 2:\n\nInput: s = \"abcde\", t = \"edbac\"\nOutput: 12\nExplanation: The permutation difference between s and t is equal to |0 - 3| + |1 - 2| + |2 - 4| + |3 - 1| + |4 - 0| = 12.\n\n \nConstraints:\n\n1 <= s.length <= 26\nEach character occurs at most once in s.\nt is a permutation of s.\ns consists only of lowercase English letters.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def findPermutationDifference(self, s: str, t: str) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nclass Solution:\n    def findPermutationDifference(self, s: str, t: str) -> int:\n        # Create a dictionary to store the index of each character in string s\n        index_map = {char: idx for idx, char in enumerate(s)}\n        \n        # Initialize the permutation difference\n        permutation_difference = 0\n        \n        # Calculate the permutation difference by comparing indices in s and t\n        for idx, char in enumerate(t):\n            permutation_difference += abs(idx - index_map[char])\n        \n        return permutation_difference\n```\n\nThis solution works as follows:\n1. We first create a dictionary `index_map` that maps each character in string `s` to its index.\n2. We initialize a variable `permutation_difference` to 0.\n3. We iterate over each character in string `t` and for each character, we calculate the absolute difference between its index in `t` and its index in `s` (using the `index_map` dictionary).\n4. We add this absolute difference to `permutation_difference`.\n5. Finally, we return the `permutation_difference`.\n\nThis solution efficiently computes the required permutation difference in O(n) time complexity, where n is the length of the strings `s` and `t`. Given the constraints, this is optimal.",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Hash Table",
        "String"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings equal.\n \nExample 1:\n\nInput: s1 = \"sea\", s2 = \"eat\"\nOutput: 231\nExplanation: Deleting \"s\" from \"sea\" adds the ASCII value of \"s\" (115) to the sum.\nDeleting \"t\" from \"eat\" adds 116 to the sum.\nAt the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\n\nExample 2:\n\nInput: s1 = \"delete\", s2 = \"leet\"\nOutput: 403\nExplanation: Deleting \"dee\" from \"delete\" to turn the string into \"let\",\nadds 100[d] + 101[e] + 101[e] to the sum.\nDeleting \"e\" from \"leet\" adds 101[e] to the sum.\nAt the end, both strings are equal to \"let\", and the answer is 100+101+101+101 = 403.\nIf instead we turned both strings into \"lee\" or \"eet\", we would get answers of 433 or 417, which are higher.\n\n \nConstraints:\n\n1 <= s1.length, s2.length <= 1000\ns1 and s2 consist of lowercase English letters.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "To solve the problem of finding the lowest ASCII sum of deleted characters to make two strings equal, we can use dynamic programming. The idea is to use a 2D DP table where `dp[i][j]` represents the minimum ASCII sum of deleted characters to make `s1[0:i]` equal to `s2[0:j]`.\n\nHere's the step-by-step approach:\n\n1. **Initialization**: Create a 2D list `dp` with dimensions `(m+1) x (n+1)`, where `m` is the length of `s1` and `n` is the length of `s2`. Initialize `dp[0][0]` to 0 because no characters need to be deleted if both strings are empty.\n\n2. **Base Cases**:\n   - For `dp[i][0]`, the cost is the sum of ASCII values of the first `i` characters of `s1` because we need to delete all characters in `s1` to match the empty string `s2`.\n   - For `dp[0][j]`, the cost is the sum of ASCII values of the first `j` characters of `s2` because we need to delete all characters in `s2` to match the empty string `s1`.\n\n3. **DP Transition**:\n   - If `s1[i-1] == s2[j-1]`, then no new deletion cost is added, so `dp[i][j] = dp[i-1][j-1]`.\n   - If `s1[i-1] != s2[j-1]`, we have two choices:\n     - Delete `s1[i-1]` and add its ASCII value to the cost: `dp[i][j] = dp[i-1][j] + ord(s1[i-1])`.\n     - Delete `s2[j-1]` and add its ASCII value to the cost: `dp[i][j] = dp[i][j-1] + ord(s2[j-1])`.\n   - We take the minimum of these two choices: `dp[i][j] = min(dp[i-1][j] + ord(s1[i-1]), dp[i][j-1] + ord(s2[j-1]))`.\n\n4. **Result**: The value at `dp[m][n]` will be the minimum ASCII sum of deleted characters to make `s1` equal to `s2`.\n\nHere is the implementation of the above approach:\n\n```python\nclass Solution:\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        # Initialize the first column\n        for i in range(1, m + 1):\n            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n        \n        # Initialize the first row\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n        \n        # Fill the rest of the dp table\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))\n        \n        return dp[m][n]\n```\n\nThis solution efficiently computes the minimum ASCII sum of deleted characters using dynamic programming with a time complexity of \\(O(m \\times n)\\) and a space complexity of \\(O(m \\times n)\\), where \\(m\\) and \\(n\\) are the lengths of `s1` and `s2`, respectively.",
    "meta_data": {
      "difficulty": "Medium",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are an ant tasked with adding n new rooms numbered 0 to n-1 to your colony. You are given the expansion plan as a 0-indexed integer array of length n, prevRoom, where prevRoom[i] indicates that you must build room prevRoom[i] before building room i, and these two rooms must be connected directly. Room 0 is already built, so prevRoom[0] = -1. The expansion plan is given such that once all the rooms are built, every room will be reachable from room 0.\\r\n\\r\nYou can only build one room at a time, and you can travel freely between rooms you have already built only if they are connected. You can choose to build any room as long as its previous room is already built.\\r\n\\r\nReturn the number of different orders you can build all the rooms in. Since the answer may be large, return it modulo 109 + 7.\\r\n\\r\n \\r\nExample 1:\\r\n\\r\n\\r\nInput: prevRoom = [-1,0,1]\\r\nOutput: 1\\r\nExplanation: There is only one way to build the additional rooms: 0 → 1 → 2\\r\n\\r\n\\r\nExample 2:\\r\n\\r\n\\r\n\\r\nInput: prevRoom = [-1,0,0,1,2]\\r\nOutput: 6\\r\nExplanation:\\r\nThe 6 ways are:\\r\n0 → 1 → 3 → 2 → 4\\r\n0 → 2 → 4 → 1 → 3\\r\n0 → 1 → 2 → 3 → 4\\r\n0 → 1 → 2 → 4 → 3\\r\n0 → 2 → 1 → 3 → 4\\r\n0 → 2 → 1 → 4 → 3\\r\n\\r\n\\r\n \\r\nConstraints:\\r\n\\r\n\\r\n\tn == prevRoom.length\\r\n\t2 <= n <= 105\\r\n\tprevRoom[0] == -1\\r\n\t0 <= prevRoom[i] < n for all 1 <= i < n\\r\n\tEvery room is reachable from room 0 once all the rooms are built.\\r\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def waysToBuildRooms(self, prevRoom: List[int]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "To solve this problem, we need to count the number of ways to build the rooms according to the given constraints. The problem can be approached using dynamic programming and combinatorics.\n\nHere's a step-by-step explanation of the solution:\n\n1. **Graph Construction**: First, we need to construct the graph from the `prevRoom` array. Each room points to its previous room, so we can build an adjacency list to represent this structure.\n\n2. **Depth-First Search (DFS)**: We will use DFS to traverse the graph and calculate the number of ways to build the subtree rooted at each node. The number of ways to build a subtree rooted at a node is determined by the number of ways to arrange its children.\n\n3. **Combinatorial Calculation**: For each node, we need to calculate the number of ways to interleave the construction of its children. This can be done using combinatorics, specifically binomial coefficients. The number of ways to interleave `k1` tasks of one type and `k2` tasks of another type is given by the binomial coefficient `C(k1 + k2, k1)`.\n\n4. **Dynamic Programming**: We use dynamic programming to store the number of ways to build the subtree rooted at each node to avoid recomputation.\n\n5. **Modulo Operation**: Since the result can be very large, we take the result modulo \\(10^9 + 7\\).\n\nHere is the implementation of the solution:\n\n```python\nfrom typing import List\nfrom math import comb\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def waysToBuildRooms(self, prevRoom: List[int]) -> int:\n        n = len(prevRoom)\n        # Build the graph\n        graph = [[] for _ in range(n)]\n        for i in range(1, n):\n            graph[prevRoom[i]].append(i)\n        \n        # DFS function to calculate the number of ways to build the subtree rooted at node\n        def dfs(node):\n            if not graph[node]:\n                return 1, 1  # (number of ways, total number of rooms in the subtree)\n            total_ways = 1\n            total_rooms = 0\n            for child in graph[node]:\n                child_ways, child_rooms = dfs(child)\n                total_ways = (total_ways * child_ways * comb(total_rooms + child_rooms, child_rooms)) % MOD\n                total_rooms += child_rooms\n            return total_ways, total_rooms + 1\n        \n        return dfs(0)[0]\n```\n\n### Explanation of the Code:\n- **Graph Construction**: We create an adjacency list `graph` where each entry `graph[i]` contains the list of children of node `i`.\n- **DFS Function**: The `dfs` function returns a tuple `(ways, rooms)` where `ways` is the number of ways to build the subtree rooted at the current node, and `rooms` is the total number of rooms in that subtree.\n  - If the node has no children, it returns `(1, 1)` because there's only one way to build a single room.\n  - For each child, it recursively calculates the number of ways to build the subtree rooted at the child.\n  - It then calculates the number of ways to interleave the construction of the children using the binomial coefficient.\n  - The total number of ways to build the current subtree is updated by multiplying the ways to build the children and the interleaving ways, modulo \\(10^9 + 7\\).\n- **Return Value**: The function `dfs(0)[0]` returns the number of ways to build the entire tree starting from room 0.\n\nThis solution efficiently calculates the number of ways to build the rooms using combinatorial techniques and dynamic programming, ensuring that the result fits within the required modulo constraint.",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Tree",
        "Graph",
        "Topological Sort",
        "Math",
        "Dynamic Programming",
        "Combinatorics"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given an undirected graph. You are given an integer n which is the number of nodes in the graph and an array edges, where each edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi.\nA connected trio is a set of three nodes where there is an edge between every pair of them.\nThe degree of a connected trio is the number of edges where one endpoint is in the trio, and the other is not.\nReturn the minimum degree of a connected trio in the graph, or -1 if the graph has no connected trios.\n \nExample 1:\n\n\nInput: n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]\nOutput: 3\nExplanation: There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.\n\nExample 2:\n\n\nInput: n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]\nOutput: 0\nExplanation: There are exactly three trios:\n1) [1,4,3] with degree 0.\n2) [2,5,6] with degree 2.\n3) [5,6,7] with degree 2.\n\n \nConstraints:\n\n2 <= n <= 400\nedges[i].length == 2\n1 <= edges.length <= n * (n-1) / 2\n1 <= ui, vi <= n\nui != vi\nThere are no repeated edges.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:\n        # Create an adjacency matrix to represent the graph\n        adj_matrix = [[0] * (n + 1) for _ in range(n + 1)]\n        degree = [0] * (n + 1)\n        \n        # Fill the adjacency matrix and calculate the degree of each node\n        for u, v in edges:\n            adj_matrix[u][v] = 1\n            adj_matrix[v][u] = 1\n            degree[u] += 1\n            degree[v] += 1\n        \n        min_degree = float('inf')\n        found_trio = False\n        \n        # Check all possible trios\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                for k in range(j + 1, n + 1):\n                    if adj_matrix[i][j] and adj_matrix[j][k] and adj_matrix[k][i]:\n                        # Calculate the degree of the trio\n                        trio_degree = degree[i] + degree[j] + degree[k] - 6\n                        min_degree = min(min_degree, trio_degree)\n                        found_trio = True\n        \n        return min_degree if found_trio else -1\n```\n\n### Explanation:\n1. **Graph Representation**: We use an adjacency matrix `adj_matrix` to represent the graph. This matrix helps us quickly check if there is an edge between any two nodes.\n2. **Degree Calculation**: We also maintain an array `degree` to store the degree of each node.\n3. **Trio Checking**: We iterate through all possible combinations of three nodes `(i, j, k)` and check if they form a trio by verifying if there are edges between each pair of these nodes.\n4. **Degree of Trio**: If a trio is found, we calculate its degree by summing the degrees of the three nodes and subtracting 6 (since each edge within the trio is counted twice).\n5. **Result**: We keep track of the minimum degree of any trio found. If no trio is found, we return `-1`. Otherwise, we return the minimum degree found.",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Graph"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven an array of positive integers nums, return the maximum possible sum of an strictly increasing subarray in nums.\nA subarray is defined as a contiguous sequence of numbers in an array.\n \nExample 1:\n\nInput: nums = [10,20,30,5,10,50]\nOutput: 65\nExplanation: [5,10,50] is the ascending subarray with the maximum sum of 65.\n\nExample 2:\n\nInput: nums = [10,20,30,40,50]\nOutput: 150\nExplanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.\n\nExample 3:\n\nInput: nums = [12,17,15,13,10,11,12]\nOutput: 33\nExplanation: [10,11,12] is the ascending subarray with the maximum sum of 33.\n\n \nConstraints:\n\n1 <= nums.length <= 100\n1 <= nums[i] <= 100\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        max_sum = current_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                current_sum += nums[i]\n            else:\n                max_sum = max(max_sum, current_sum)\n                current_sum = nums[i]\n        \n        # Final check to ensure the last subarray is considered\n        max_sum = max(max_sum, current_sum)\n        \n        return max_sum\n```\n\nThis solution iterates through the list of numbers, maintaining a running sum of the current ascending subarray. When it encounters a number that is not greater than the previous one, it compares the current sum to the maximum sum found so far and resets the current sum. Finally, it ensures the last subarray is considered by comparing it once more at the end.",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nThe XOR sum of a list is the bitwise XOR of all its elements. If the list only contains one element, then its XOR sum will be equal to this element.\n\nFor example, the XOR sum of [1,2,3,4] is equal to 1 XOR 2 XOR 3 XOR 4 = 4, and the XOR sum of [3] is equal to 3.\n\nYou are given two 0-indexed arrays arr1 and arr2 that consist only of non-negative integers.\nConsider the list containing the result of arr1[i] AND arr2[j] (bitwise AND) for every (i, j) pair where 0 <= i < arr1.length and 0 <= j < arr2.length.\nReturn the XOR sum of the aforementioned list.\n \nExample 1:\n\nInput: arr1 = [1,2,3], arr2 = [6,5]\nOutput: 0\nExplanation: The list = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1].\nThe XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0.\n\nExample 2:\n\nInput: arr1 = [12], arr2 = [4]\nOutput: 4\nExplanation: The list = [12 AND 4] = [4]. The XOR sum = 4.\n\n \nConstraints:\n\n1 <= arr1.length, arr2.length <= 105\n0 <= arr1[i], arr2[j] <= 109\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "To solve this problem efficiently, we can leverage the properties of the XOR and AND bitwise operations. Instead of generating all possible pairs (which would be inefficient given the constraints), we can use the following property of XOR and AND:\n\n\\[\n(\\text{XOR of all elements in } \\text{arr1}) \\text{ AND } (\\text{XOR of all elements in } \\text{arr2})\n\\]\n\nThis property allows us to compute the XOR sum of the AND results in linear time, which is efficient given the constraints.\n\nHere's the implementation:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:\n        xor_arr1 = 0\n        xor_arr2 = 0\n        \n        # Compute XOR of all elements in arr1\n        for num in arr1:\n            xor_arr1 ^= num\n        \n        # Compute XOR of all elements in arr2\n        for num in arr2:\n            xor_arr2 ^= num\n        \n        # Return the AND of the two XOR results\n        return xor_arr1 & xor_arr2\n```\n\nThis solution works as follows:\n1. Compute the XOR of all elements in `arr1` and store it in `xor_arr1`.\n2. Compute the XOR of all elements in `arr2` and store it in `xor_arr2`.\n3. Return the result of `xor_arr1 AND xor_arr2`.\n\nThis approach ensures that we only iterate through each array once, making the solution efficient with a time complexity of \\(O(n + m)\\), where \\(n\\) and \\(m\\) are the lengths of `arr1` and `arr2`, respectively.",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Bit Manipulation",
        "Array",
        "Math"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nIn a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.\nIf the town judge exists, then:\n\nThe town judge trusts nobody.\nEverybody (except for the town judge) trusts the town judge.\nThere is exactly one person that satisfies properties 1 and 2.\n\nYou are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.\nReturn the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.\n \nExample 1:\n\nInput: n = 2, trust = [[1,2]]\nOutput: 2\n\nExample 2:\n\nInput: n = 3, trust = [[1,3],[2,3]]\nOutput: 3\n\nExample 3:\n\nInput: n = 3, trust = [[1,3],[2,3],[3,1]]\nOutput: -1\n\n \nConstraints:\n\n1 <= n <= 1000\n0 <= trust.length <= 104\ntrust[i].length == 2\nAll the pairs of trust are unique.\nai != bi\n1 <= ai, bi <= n\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        # Initialize in-degree and out-degree arrays\n        in_degree = [0] * (n + 1)\n        out_degree = [0] * (n + 1)\n        \n        # Calculate in-degrees and out-degrees\n        for a, b in trust:\n            out_degree[a] += 1\n            in_degree[b] += 1\n        \n        # Find the judge\n        for i in range(1, n + 1):\n            if in_degree[i] == n - 1 and out_degree[i] == 0:\n                return i\n        \n        return -1\n```\n\nThis solution works as follows:\n- We use two arrays, `in_degree` and `out_degree`, to keep track of how many people trust each person and how many people each person trusts, respectively.\n- We iterate through the `trust` list to populate these arrays.\n- We then check each person to see if they have `n-1` people trusting them (since the judge is trusted by everyone except themselves) and trust nobody.\n- If such a person is found, we return their label. If no such person exists, we return `-1`.",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Graph",
        "Array",
        "Hash Table"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven a rectangular pizza represented as a rows x cols matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts. \nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.\n \nExample 1:\n\n\nInput: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n\nExample 2:\n\nInput: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1\n\nExample 3:\n\nInput: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1\n\n \nConstraints:\n\n1 <= rows, cols <= 50\nrows == pizza.length\ncols == pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A' and '.' only.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom functools import cache\nfrom typing import List\n\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        @cache\n        def dfs(i: int, j: int, k: int) -> int:\n            if k == 0:\n                return int(s[m][n] - s[i][n] - s[m][j] + s[i][j] > 0)\n            ans = 0\n            for x in range(i + 1, m):\n                if s[x][n] - s[i][n] - s[x][j] + s[i][j] > 0:\n                    ans += dfs(x, j, k - 1)\n            for y in range(j + 1, n):\n                if s[m][y] - s[i][y] - s[m][j] + s[i][j] > 0:\n                    ans += dfs(i, y, k - 1)\n            return ans % mod\n\n        mod = 10**9 + 7\n        m, n = len(pizza), len(pizza[0])\n        s = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, row in enumerate(pizza, 1):\n            for j, c in enumerate(row, 1):\n                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + int(c == 'A')\n        return dfs(0, 0, k - 1)\n```\n\nThis solution uses dynamic programming with memoization to solve the problem. The `dfs` function is a recursive function that calculates the number of ways to cut the remaining part of the pizza starting from position `(i, j)` with `k` cuts left. The `s` matrix is a prefix sum matrix that helps in quickly calculating the number of apples in any submatrix of the pizza. The result is returned modulo \\(10^9 + 7\\).",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Memoization",
        "Array",
        "Dynamic Programming",
        "Matrix",
        "Prefix Sum"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nThe set [1, 2, 3, ..., n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\n\"123\"\n\"132\"\n\"213\"\n\"231\"\n\"312\"\n\"321\"\n\nGiven n and k, return the kth permutation sequence.\n \nExample 1:\nInput: n = 3, k = 3\nOutput: \"213\"\nExample 2:\nInput: n = 4, k = 9\nOutput: \"2314\"\nExample 3:\nInput: n = 3, k = 1\nOutput: \"123\"\n\n \nConstraints:\n\n1 <= n <= 9\n1 <= k <= n!\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        ans = []\n        vis = [False] * (n + 1)\n        for i in range(n):\n            fact = 1\n            for j in range(1, n - i):\n                fact *= j\n            for j in range(1, n + 1):\n                if not vis[j]:\n                    if k > fact:\n                        k -= fact\n                    else:\n                        ans.append(str(j))\n                        vis[j] = True\n                        break\n        return ''.join(ans)\n```",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Recursion",
        "Math"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nThere exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.\n \nExample 1:\n\n\nInput: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.\n\nExample 2:\n\n\nInput: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve.\n\n \nConstraints:\n\n1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi <= n - 1\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "To solve this problem, we need to find the optimal set of non-adjacent nodes to halve their prices such that the total price sum of all given trips is minimized. Here's the step-by-step approach:\n\n1. **Graph Representation**: Represent the tree using an adjacency list.\n2. **Path Calculation**: For each trip, find the path from the start node to the end node using a depth-first search (DFS) or breadth-first search (BFS).\n3. **Frequency Count**: Count the frequency of each node being visited across all trips.\n4. **Cost Calculation**: Calculate the total cost of all trips without any price reductions.\n5. **Dynamic Programming on Trees**: Use dynamic programming to determine the optimal set of non-adjacent nodes to halve their prices. This involves two states for each node:\n   - The cost if we halve the price of the current node.\n   - The cost if we do not halve the price of the current node.\n6. **Final Calculation**: Use the results from the dynamic programming step to determine the minimum total price sum.\n\nHere is the complete Python solution:\n\n```python\nfrom collections import defaultdict, Counter\nfrom typing import List\n\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        # Step 1: Build the adjacency list for the tree\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        # Step 2: Function to find the path from start to end using DFS\n        def find_path(start, end, parent):\n            if start == end:\n                return [start]\n            for neighbor in graph[start]:\n                if neighbor != parent:\n                    path = find_path(neighbor, end, start)\n                    if path:\n                        return [start] + path\n            return None\n        \n        # Step 3: Count the frequency of each node being visited across all trips\n        node_count = Counter()\n        for start, end in trips:\n            path = find_path(start, end, -1)\n            for node in path:\n                node_count[node] += 1\n        \n        # Step 4: Calculate the total cost without any price reductions\n        total_cost = sum(node_count[node] * price[node] for node in node_count)\n        \n        # Step 5: Dynamic Programming on Trees\n        # dp[node][0]: cost if we do not halve the price of node\n        # dp[node][1]: cost if we halve the price of node\n        dp = [[0, 0] for _ in range(n)]\n        \n        def dfs(node, parent):\n            dp[node][0] = node_count[node] * price[node]\n            dp[node][1] = dp[node][0] // 2\n            \n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    dfs(neighbor, node)\n                    dp[node][0] += min(dp[neighbor][0], dp[neighbor][1])\n                    dp[node][1] += dp[neighbor][0]\n        \n        # Start DFS from any node, as it is a tree\n        dfs(0, -1)\n        \n        # Step 6: The result is the minimum of the two states for the root node\n        return min(dp[0][0], dp[0][1])\n```\n\nThis solution effectively finds the optimal set of non-adjacent nodes to halve their prices, ensuring the minimum total price sum for all given trips. The use of dynamic programming helps in efficiently solving the problem within the given constraints.",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Graph",
        "Array",
        "Dynamic Programming"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given an m x n grid grid of values 0, 1, or 2, where:\n\neach 0 marks an empty land that you can pass by freely,\neach 1 marks a building that you cannot pass through, and\neach 2 marks an obstacle that you cannot pass through.\n\nYou want to build a house on an empty land that reaches all buildings in the shortest total travel distance. You can only move up, down, left, and right.\nReturn the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.\nThe total travel distance is the sum of the distances between the houses of the friends and the meeting point.\nThe distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\n \nExample 1:\n\n\nInput: grid = [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]\nOutput: 7\nExplanation: Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).\nThe point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal.\nSo return 7.\n\nExample 2:\n\nInput: grid = [[1,0]]\nOutput: 1\n\nExample 3:\n\nInput: grid = [[1]]\nOutput: -1\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 50\ngrid[i][j] is either 0, 1, or 2.\nThere will be at least one building in the grid.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def shortestDistance(self, grid: List[List[int]]) -> int:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\nfrom collections import deque\n\nclass Solution:\n    def shortestDistance(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return -1\n        \n        m, n = len(grid), len(grid[0])\n        total_distances = [[0] * n for _ in range(m)]\n        buildings_reached = [[0] * n for _ in range(m)]\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n        total_buildings = 0\n        \n        def bfs(start_x, start_y):\n            visited = [[False] * n for _ in range(m)]\n            queue = deque([(start_x, start_y, 0)])\n            visited[start_x][start_y] = True\n            min_distance = float('inf')\n            \n            while queue:\n                x, y, dist = queue.popleft()\n                \n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    \n                    if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:\n                        visited[nx][ny] = True\n                        buildings_reached[nx][ny] += 1\n                        total_distances[nx][ny] += dist + 1\n                        queue.append((nx, ny, dist + 1))\n                        if buildings_reached[nx][ny] == total_buildings:\n                            min_distance = min(min_distance, total_distances[nx][ny])\n            \n            return min_distance\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    total_buildings += 1\n                    min_distance = bfs(i, j)\n                    if min_distance == float('inf'):\n                        return -1\n        \n        min_dist = float('inf')\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0 and buildings_reached[i][j] == total_buildings:\n                    min_dist = min(min_dist, total_distances[i][j])\n        \n        return min_dist if min_dist != float('inf') else -1\n```",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Breadth-First Search",
        "Array",
        "Matrix"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given a sorted unique integer array nums.\nA range [a,b] is the set of all integers from a to b (inclusive).\nReturn the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\nEach range [a,b] in the list should be output as:\n\n\"a->b\" if a != b\n\"a\" if a == b\n\n \nExample 1:\n\nInput: nums = [0,1,2,4,5,7]\nOutput: [\"0->2\",\"4->5\",\"7\"]\nExplanation: The ranges are:\n[0,2] --> \"0->2\"\n[4,5] --> \"4->5\"\n[7,7] --> \"7\"\n\nExample 2:\n\nInput: nums = [0,2,3,4,6,8,9]\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\nExplanation: The ranges are:\n[0,0] --> \"0\"\n[2,4] --> \"2->4\"\n[6,6] --> \"6\"\n[8,9] --> \"8->9\"\n\n \nConstraints:\n\n0 <= nums.length <= 20\n-231 <= nums[i] <= 231 - 1\nAll the values of nums are unique.\nnums is sorted in ascending order.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nclass Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        if not nums:\n            return []\n        \n        ranges = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1] + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    ranges.append(f\"{start}\")\n                else:\n                    ranges.append(f\"{start}->{end}\")\n                start = nums[i]\n                end = nums[i]\n        \n        # Add the last range\n        if start == end:\n            ranges.append(f\"{start}\")\n        else:\n            ranges.append(f\"{start}->{end}\")\n        \n        return ranges\n```",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou are given an array of positive integers nums.\nAlice and Bob are playing a game. In the game, Alice can choose either all single-digit numbers or all double-digit numbers from nums, and the rest of the numbers are given to Bob. Alice wins if the sum of her numbers is strictly greater than the sum of Bob's numbers.\nReturn true if Alice can win this game, otherwise, return false.\n \nExample 1:\n\nInput: nums = [1,2,3,4,10]\nOutput: false\nExplanation:\nAlice cannot win by choosing either single-digit or double-digit numbers.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5,14]\nOutput: true\nExplanation:\nAlice can win by choosing single-digit numbers which have a sum equal to 15.\n\nExample 3:\n\nInput: nums = [5,5,5,25]\nOutput: true\nExplanation:\nAlice can win by choosing double-digit numbers which have a sum equal to 25.\n\n \nConstraints:\n\n1 <= nums.length <= 100\n1 <= nums[i] <= 99\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        sum_single_digit = 0\n        sum_double_digit = 0\n        \n        for num in nums:\n            if num < 10:\n                sum_single_digit += num\n            else:\n                sum_double_digit += num\n        \n        return sum_single_digit > sum_double_digit or sum_double_digit > sum_single_digit\n```\n\nThis solution calculates the sum of single-digit and double-digit numbers separately and checks if Alice can win by choosing either all single-digit numbers or all double-digit numbers. If either sum is strictly greater than the other, Alice can win, and the function returns `True`. Otherwise, it returns `False`.",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nGiven a string s, return true if s is a good string, or false otherwise.\nA string s is good if all the characters that appear in s have the same number of occurrences (i.e., the same frequency).\n \nExample 1:\n\nInput: s = \"abacbc\"\nOutput: true\nExplanation: The characters that appear in s are 'a', 'b', and 'c'. All characters occur 2 times in s.\n\nExample 2:\n\nInput: s = \"aaabb\"\nOutput: false\nExplanation: The characters that appear in s are 'a' and 'b'.\n'a' occurs 3 times while 'b' occurs 2 times, which is not the same number of times.\n\n \nConstraints:\n\n1 <= s.length <= 1000\ns consists of lowercase English letters.\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def areOccurrencesEqual(self, s: str) -> bool:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nclass Solution:\n    def areOccurrencesEqual(self, s: str) -> bool:\n        # Create a dictionary to count occurrences of each character\n        char_count = {}\n        \n        # Count each character in the string\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # Get the set of all occurrence counts\n        occurrence_set = set(char_count.values())\n        \n        # If all characters have the same frequency, the set will have only one element\n        return len(occurrence_set) == 1\n```\n\nThis solution counts the occurrences of each character in the string and checks if all characters have the same frequency by examining if the set of occurrence counts has only one unique value.",
    "meta_data": {
      "difficulty": "Easy",
      "tags": [
        "Hash Table",
        "String",
        "Counting"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nYou want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle.\nFor every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:\n\nYou choose any number of obstacles between 0 and i inclusive.\nYou must include the ith obstacle in the course.\nYou must put the chosen obstacles in the same order as they appear in obstacles.\nEvery obstacle (except the first) is taller than or the same height as the obstacle immediately before it.\n\nReturn an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.\n \nExample 1:\n\nInput: obstacles = [1,2,3,2]\nOutput: [1,2,3,3]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [1], [1] has length 1.\n- i = 1: [1,2], [1,2] has length 2.\n- i = 2: [1,2,3], [1,2,3] has length 3.\n- i = 3: [1,2,3,2], [1,2,2] has length 3.\n\nExample 2:\n\nInput: obstacles = [2,2,1]\nOutput: [1,2,1]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [2], [2] has length 1.\n- i = 1: [2,2], [2,2] has length 2.\n- i = 2: [2,2,1], [1] has length 1.\n\nExample 3:\n\nInput: obstacles = [3,1,5,6,4,2]\nOutput: [1,1,2,3,2,2]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [3], [3] has length 1.\n- i = 1: [3,1], [1] has length 1.\n- i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.\n- i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.\n- i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.\n- i = 5: [3,1,5,6,4,2], [1,2] has length 2.\n\n \nConstraints:\n\nn == obstacles.length\n1 <= n <= 105\n1 <= obstacles[i] <= 107\n\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\nimport bisect\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        n = len(obstacles)\n        dp = [float('inf')] * n\n        result = [0] * n\n        \n        for i, height in enumerate(obstacles):\n            # Find the position to replace in dp array\n            pos = bisect.bisect_right(dp, height)\n            dp[pos] = height\n            result[i] = pos + 1\n        \n        return result\n```\n\n### Explanation:\n- We use a `dp` array to keep track of the smallest ending value of obstacle courses of different lengths.\n- `dp[pos]` will be the smallest ending value of any obstacle course of length `pos + 1`.\n- For each obstacle, we use `bisect_right` to find the position in `dp` where the current obstacle can replace an existing value or extend the list.\n- `result[i]` is set to `pos + 1` because `pos` is 0-indexed, but we want the length of the obstacle course which is 1-indexed.\n- This approach ensures that we efficiently find the length of the longest obstacle course ending at each position in `O(n log n)` time complexity.",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Binary Indexed Tree",
        "Array",
        "Binary Search"
      ],
      "source": "leetcode_dataset"
    }
  },
  {
    "prompt": "You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\n\n### Question:\nThere are n cities numbered from 1 to n. You are given an array edges of size n-1, where edges[i] = [ui, vi] represents a bidirectional edge between cities ui and vi. There exists a unique path between each pair of cities. In other words, the cities form a tree.\\r\n\\r\nA subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\\r\n\\r\nFor each d from 1 to n-1, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to d.\\r\n\\r\nReturn an array of size n-1 where the dth element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to d.\\r\n\\r\nNotice that the distance between the two cities is the number of edges in the path between them.\\r\n\\r\n \\r\nExample 1:\\r\n\\r\n\\r\n\\r\n\\r\nInput: n = 4, edges = [[1,2],[2,3],[2,4]]\\r\nOutput: [3,4,0]\\r\nExplanation:\\r\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\\r\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\\r\nNo subtree has two nodes where the max distance between them is 3.\\r\n\\r\n\\r\nExample 2:\\r\n\\r\n\\r\nInput: n = 2, edges = [[1,2]]\\r\nOutput: [1]\\r\n\\r\n\\r\nExample 3:\\r\n\\r\n\\r\nInput: n = 3, edges = [[1,2],[2,3]]\\r\nOutput: [2,1]\\r\n\\r\n\\r\n \\r\nConstraints:\\r\n\\r\n\\r\n\t2 <= n <= 15\\r\n\tedges.length == n-1\\r\n\tedges[i].length == 2\\r\n\t1 <= ui, vi <= n\\r\n\tAll pairs (ui, vi) are distinct.\\r\n\n\n### Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\n```python\nclass Solution:\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n        \n```\n\n### Answer: (use the provided format with backticks)\n",
    "answer": "```python\nfrom typing import List\n\nclass Solution:\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n        from collections import defaultdict\n        \n        # Build the graph\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u-1].append(v-1)\n            graph[v-1].append(u-1)\n        \n        # Function to find the diameter of a subtree rooted at 'root'\n        def find_diameter(subtree):\n            def dfs(node, parent):\n                nonlocal max_diameter\n                first_max = second_max = 0\n                for neighbor in graph[node]:\n                    if neighbor in subtree and neighbor != parent:\n                        dist = dfs(neighbor, node) + 1\n                        if dist > first_max:\n                            second_max = first_max\n                            first_max = dist\n                        elif dist > second_max:\n                            second_max = dist\n                max_diameter = max(max_diameter, first_max + second_max)\n                return first_max\n            \n            max_diameter = 0\n            dfs(root, -1)\n            return max_diameter\n        \n        # Generate all possible subtrees\n        result = [0] * (n - 1)\n        for i in range(1 << n):\n            subtree = {j for j in range(n) if (i & (1 << j))}\n            if len(subtree) < 2:\n                continue\n            \n            # Find the root of the subtree\n            for root in subtree:\n                if all(neighbor in subtree for neighbor in graph[root]):\n                    break\n            \n            # Check if the subset forms a connected subtree\n            visited = set()\n            def is_connected(node):\n                if node in visited:\n                    return\n                visited.add(node)\n                for neighbor in graph[node]:\n                    if neighbor in subtree:\n                        is_connected(neighbor)\n            \n            is_connected(root)\n            if visited == subtree:\n                diameter = find_diameter(subtree)\n                if diameter > 0:\n                    result[diameter - 1] += 1\n        \n        return result\n```\n\nThis solution generates all possible subsets of cities and checks if they form a connected subtree. For each connected subtree, it calculates the diameter and counts the number of subtrees for each possible diameter. The solution uses bit manipulation to generate all subsets and depth-first search (DFS) to determine the connectivity and diameter of each subtree.",
    "meta_data": {
      "difficulty": "Hard",
      "tags": [
        "Bit Manipulation",
        "Tree",
        "Dynamic Programming",
        "Bitmask",
        "Enumeration"
      ],
      "source": "leetcode_dataset"
    }
  }
]